{"version":3,"sources":["notatrix.min.js"],"names":["f","exports","module","define","amd","window","global","self","this","nx","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","root","previousUnderscore","_","ArrayProto","Array","prototype","ObjProto","Object","SymbolProto","Symbol","push","slice","toString","hasOwnProperty","nativeIsArray","isArray","nativeKeys","keys","nativeCreate","create","Ctor","obj","_wrapped","nodeType","VERSION","builtinIteratee","optimizeCb","func","context","argCount","value","index","collection","accumulator","apply","arguments","cb","iteratee","identity","isFunction","isObject","matcher","property","Infinity","restArguments","startIndex","Math","max","rest","args","baseCreate","result","shallowProperty","key","has","path","deepGet","MAX_ARRAY_INDEX","pow","getLength","isArrayLike","each","forEach","map","collect","results","currentKey","createReduce","dir","memo","initial","reducer","reduce","foldl","inject","reduceRight","foldr","find","detect","predicate","findIndex","findKey","filter","select","list","reject","negate","every","all","some","any","contains","includes","include","item","fromIndex","guard","values","indexOf","invoke","contextPath","method","pluck","where","attrs","findWhere","computed","lastComputed","v","min","shuffle","sample","random","clone","last","rand","temp","sortBy","criteria","sort","left","right","b","group","behavior","partition","groupBy","indexBy","countBy","reStrSymbol","toArray","isString","match","size","pass","first","head","take","array","tail","drop","compact","Boolean","flatten","input","shallow","strict","output","idx","isArguments","j","len","without","otherArrays","difference","uniq","unique","isSorted","isBoolean","seen","union","arrays","intersection","argsLength","unzip","zip","object","createPredicateIndexFinder","findLastIndex","sortedIndex","low","high","mid","floor","createIndexFinder","predicateFind","isNaN","lastIndexOf","range","start","stop","step","ceil","chunk","count","executeBound","sourceFunc","boundFunc","callingContext","bind","TypeError","bound","callArgs","concat","partial","boundArgs","placeholder","position","bindAll","memoize","hasher","cache","address","delay","wait","setTimeout","defer","throttle","options","timeout","previous","later","leading","now","throttled","remaining","clearTimeout","trailing","cancel","debounce","immediate","debounced","callNow","wrap","wrapper","compose","after","times","before","once","hasEnumBug","propertyIsEnumerable","nonEnumerableProps","collectNonEnumProps","nonEnumIdx","constructor","proto","prop","allKeys","mapObject","pairs","invert","functions","methods","names","createAssigner","keysFunc","defaults","source","l","extend","extendOwn","assign","eq","deepEq","keyInObj","pick","omit","String","props","tap","interceptor","isMatch","aStack","bStack","type","className","valueOf","areArrays","aCtor","bCtor","pop","isEqual","isEmpty","isElement","name","nodelist","document","childNodes","Int8Array","isFinite","isSymbol","parseFloat","isNumber","isNull","isUndefined","noConflict","constant","noop","propertyOf","matches","accum","Date","getTime","escapeMap","&","<",">","\"","'","`","unescapeMap","createEscaper","escaper","join","testRegexp","RegExp","replaceRegexp","string","test","replace","escape","unescape","fallback","idCounter","uniqueId","prefix","id","templateSettings","evaluate","interpolate","noMatch","escapes","\\","\r","\n"," "," ","escapeRegExp","escapeChar","template","text","settings","oldSettings","render","offset","variable","Function","data","argument","chain","instance","_chain","chainResult","mixin","toJSON","2","_typeof","iterator","_createClass","defineProperties","target","descriptor","enumerable","configurable","writable","defineProperty","Constructor","protoProps","staticProps","NotatrixError","sanitize","str","parseEnhancedString","heads","split","token","deprel","evaluatePunctPos","ana","puncts","sentence","help","upostag","xpostag","cg3FormatOutput","analysis","tabs","indent","fill","tags","misc","dependency","showEmptyDependencies","lemma","fields","Analysis","params","_this","_classCallCheck","initializing","_heads","_deps","undefined","subTokens","__proto__","isSuperToken","isSubToken","parseInt","superToken","_this2","eachHead","removeHead","eachDep","dep","removeDep","splice","sourceIndex","targetIndex","subToken","insertSubTokenAt","removeSubTokenAt","callback","changeHead","_this3","removing","_this4","done","_deprel","changeDep","deps","_this5","_this6","get","_this7","field","num","form","fallbackOnText","_this8","subscripts","_this9","eles","isCurrent","clump","label","0","3","4","5","6","7","8","9","-","(",")","char","classes","pos","parent","attr","state","sourceAnalysis","targetAnalysis","ctrl","_form","_lemma","set","_upostag","_xpostag","_feats","feats","_this10","showEnhanced","getById","_this11","_this12","_this13","_misc","Proxy","receiver","./errors","underscore","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","_Error","_ref","_len","_key","getPrototypeOf","InvalidCG3Error","_NotatrixError","_ref2","_len2","_key2","InvalidCoNLLUError","_NotatrixError2","_ref3","_len3","_key3","TransformationError","_NotatrixError3","_ref4","_len4","_key4","Sentence","Token","./analysis","./sentence","./token","_slicedToArray","arr","_arr","_n","_d","_e","_s","_i","next","err","sliceIterator","regex","comment","commentContent","empty","cg3TokenStart","cg3TokenContent","paramsList","prettyOutput","catchInvalid","comments","tokens","tok","superTokenId","subTokenId","found","super","sub","atToken","newToken","fromParams","indices","getIndices","insertTokenAt","atAnalysis","newAnalysis","analysisId","insertAnalysisAt","removeTokenAt","_token$index","_token$index2","acc","JSON","stringify","trim","pushToken","conllu","lines","fromConllu","k","subTokenIndices","pushSubToken","attach","cg3","tokenLines","isToken","isContent","fromCG3","isAmbiguous","console","warn","valid","serial","sent","getIndent","line","chars","cg3StringGetForm","cg3Regex","cg3StringGetTags","chunks","cg3StringParseAnalysis","pushAnalysis","_tags","analyses","_current","_isEmpty","current","prev","removeAnalysisAt","abs","_indices","firstSubAnalysis","lastSubAnalysis"],"mappings":"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","file":"notatrix.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.nx = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n(function (global){\n//     Underscore.js 1.9.1\n//     http://underscorejs.org\n//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n            typeof global == 'object' && global.global === global && global ||\n            this ||\n            {};\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if (typeof exports != 'undefined' && !exports.nodeType) {\n    if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.9.1';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-argument case is omitted because we’re not using it.\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  var builtinIteratee;\n\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);\n    return _.property(value);\n  };\n\n  // External wrapper for our callback generator. Users may customize\n  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n  // This abstraction hides the internal-only argCount argument.\n  _.iteratee = builtinIteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // Some functions take a variable number of arguments, or a few expected\n  // arguments at the beginning and then a variable number of values to operate\n  // on. This helper accumulates all remaining arguments past the function’s\n  // argument length (or an explicit `startIndex`), into an array that becomes\n  // the last argument. Similar to ES6’s \"rest parameter\".\n  var restArguments = function(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var shallowProperty = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  var has = function(obj, path) {\n    return obj != null && hasOwnProperty.call(obj, path);\n  }\n\n  var deepGet = function(obj, path) {\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      if (obj == null) return void 0;\n      obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object.\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = shallowProperty('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  var createReduce = function(dir) {\n    // Wrap code that reassigns argument variables in a separate function than\n    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n    var reducer = function(obj, iteratee, memo, initial) {\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      if (!initial) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    };\n\n    return function(obj, iteratee, memo, context) {\n      var initial = arguments.length >= 3;\n      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n    };\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;\n    var key = keyFinder(obj, predicate, context);\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = restArguments(function(obj, path, args) {\n    var contextPath, func;\n    if (_.isFunction(path)) {\n      func = path;\n    } else if (_.isArray(path)) {\n      contextPath = path.slice(0, -1);\n      path = path[path.length - 1];\n    }\n    return _.map(obj, function(context) {\n      var method = func;\n      if (!method) {\n        if (contextPath && contextPath.length) {\n          context = deepGet(context, contextPath);\n        }\n        if (context == null) return void 0;\n        method = context[path];\n      }\n      return method == null ? method : method.apply(context, args);\n    });\n  });\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection.\n  _.shuffle = function(obj) {\n    return _.sample(obj, Infinity);\n  };\n\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    var index = 0;\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, key, list) {\n      return {\n        value: value,\n        index: index++,\n        criteria: iteratee(value, key, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior, partition) {\n    return function(obj, iteratee, context) {\n      var result = partition ? [[], []] : {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (_.isString(obj)) {\n      // Keep surrogate pair characters together\n      return obj.match(reStrSymbol);\n    }\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = group(function(result, value, pass) {\n    result[pass ? 0 : 1].push(value);\n  }, true);\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null || array.length < 1) return n == null ? void 0 : [];\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null || array.length < 1) return n == null ? void 0 : [];\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, Boolean);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, output) {\n    output = output || [];\n    var idx = output.length;\n    for (var i = 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        // Flatten current level of array or arguments object.\n        if (shallow) {\n          var j = 0, len = value.length;\n          while (j < len) output[idx++] = value[j++];\n        } else {\n          flatten(value, shallow, strict, output);\n          idx = output.length;\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = restArguments(function(array, otherArrays) {\n    return _.difference(array, otherArrays);\n  });\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // The faster algorithm will not work with an iteratee if the iteratee\n  // is not a one-to-one function, so providing an iteratee will disable\n  // the faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted && !iteratee) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = restArguments(function(arrays) {\n    return _.uniq(flatten(arrays, true, true));\n  });\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      var j;\n      for (j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = restArguments(function(array, rest) {\n    rest = flatten(rest, true, true);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  });\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices.\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = restArguments(_.unzip);\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values. Passing by pairs is the reverse of _.pairs.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions.\n  var createPredicateIndexFinder = function(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  };\n\n  // Returns the first index on an array-like that passes a predicate test.\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions.\n  var createIndexFinder = function(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    if (!step) {\n      step = stop < start ? -1 : 1;\n    }\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Chunk a single array into multiple arrays, each containing `count` or fewer\n  // items.\n  _.chunk = function(array, count) {\n    if (count == null || count < 1) return [];\n    var result = [];\n    var i = 0, length = array.length;\n    while (i < length) {\n      result.push(slice.call(array, i, i += count));\n    }\n    return result;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments.\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = restArguments(function(func, context, args) {\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var bound = restArguments(function(callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder by default, allowing any combination of arguments to be\n  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\n  _.partial = restArguments(function(func, boundArgs) {\n    var placeholder = _.partial.placeholder;\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\n  _.partial.placeholder = _;\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = restArguments(function(obj, keys) {\n    keys = flatten(keys, false, false);\n    var index = keys.length;\n    if (index < 1) throw new Error('bindAll must be passed function names');\n    while (index--) {\n      var key = keys[index];\n      obj[key] = _.bind(obj[key], obj);\n    }\n  });\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = restArguments(function(func, wait, args) {\n    return setTimeout(function() {\n      return func.apply(null, args);\n    }, wait);\n  });\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n\n    var later = function(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArguments(function(args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  _.restArguments = restArguments;\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`.\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object.\n  // In contrast to _.map it returns an object.\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = _.keys(obj),\n        length = keys.length,\n        results = {};\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  // The opposite of _.object.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`.\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, defaults) {\n    return function(obj) {\n      var length = arguments.length;\n      if (defaults) obj = Object(obj);\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!defaults || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s).\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test.\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Internal pick helper function to determine if `obj` has key `key`.\n  var keyInObj = function(value, key, obj) {\n    return key in obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = restArguments(function(obj, keys) {\n    var result = {}, iteratee = keys[0];\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n      keys = _.allKeys(obj);\n    } else {\n      iteratee = keyInObj;\n      keys = flatten(keys, false, false);\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  });\n\n  // Return a copy of the object without the blacklisted properties.\n  _.omit = restArguments(function(obj, keys) {\n    var iteratee = keys[0], context;\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n      if (keys.length > 1) context = keys[1];\n    } else {\n      keys = _.map(flatten(keys, false, false), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  });\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq, deepEq;\n  eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) return false;\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) return b !== b;\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\n    return deepEq(a, b, aStack, bStack);\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  deepEq = function(a, b, aStack, bStack) {\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN.\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n      case '[object Symbol]':\n        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\n  var nodelist = root.document && root.document.childNodes;\n  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && isNaN(obj);\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, path) {\n    if (!_.isArray(path)) {\n      return has(obj, path);\n    }\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      var key = path[i];\n      if (obj == null || !hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n      obj = obj[key];\n    }\n    return !!length;\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  // Creates a function that, when passed an object, will traverse that object’s\n  // properties down the given `path`, specified as an array of keys or indexes.\n  _.property = function(path) {\n    if (!_.isArray(path)) {\n      return shallowProperty(path);\n    }\n    return function(obj) {\n      return deepGet(obj, path);\n    };\n  };\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    if (obj == null) {\n      return function(){};\n    }\n    return function(path) {\n      return !_.isArray(path) ? obj[path] : deepGet(obj, path);\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // Traverses the children of `obj` along `path`. If a child is a function, it\n  // is invoked with its parent as context. Returns the value of the final\n  // child, or `fallback` if any child is undefined.\n  _.result = function(obj, path, fallback) {\n    if (!_.isArray(path)) path = [path];\n    var length = path.length;\n    if (!length) {\n      return _.isFunction(fallback) ? fallback.call(obj) : fallback;\n    }\n    for (var i = 0; i < length; i++) {\n      var prop = obj == null ? void 0 : obj[path[i]];\n      if (prop === void 0) {\n        prop = fallback;\n        i = length; // Ensure we don't continue iterating.\n      }\n      obj = _.isFunction(prop) ? prop.call(obj) : prop;\n    }\n    return obj;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offset.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    var render;\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var chainResult = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return chainResult(this, func.apply(_, args));\n      };\n    });\n    return _;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return chainResult(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return chainResult(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return String(this._wrapped);\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define == 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}());\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _ = require('underscore');\n\nvar NotatrixError = require('./errors').NotatrixError;\n\n/**\n * convert a string to subscripts (for ele labels)\n *\n * @param {String} str string to be subscripted\n * @return {String}\n */\nfunction toSubscript(str) {\n  var subscripts = { 0: '₀', 1: '₁', 2: '₂', 3: '₃', 4: '₄', 5: '₅',\n    6: '₆', 7: '₇', 8: '₈', 9: '₉', '-': '₋', '(': '₍', ')': '₎' };\n\n  return str.split('').map(function (char) {\n    return subscripts[char] || char;\n  }).join('');\n}\n\n/**\n * strip whitespace from a string\n *\n * @param {String} str\n * @return {String}\n */\nfunction sanitize(str) {\n  return (str || '').replace(/\\s/g, '');\n}\n\n/**\n * take a string possibly given in enhanced notation and extract the head\n *   and deprel\n *\n * e.g. `2:ccomp|3:nsubj` => `[\n *   { token: 2, deprel: 'ccomp' },\n *   { token: 3, deprel: 'nsubj' } ]`\n *\n * @param {String} str\n * @return {Array} [[Object]]\n */\nfunction parseEnhancedString(str) {\n\n  // strip whitespace in input\n  str = sanitize(str);\n\n  // keep our heads here\n  var heads = [];\n\n  // iterate over \"|\"-delimited chunks\n  _.each(str.split('|'), function (head) {\n    head = head.split(':');\n\n    // ignore it if we don't parse a head\n    if (head[0]) heads.push({\n      token: head[0],\n      deprel: head[1]\n    });\n  });\n  return heads;\n}\n\n/**\n * automatically add PUNCT pos tags to strings that consist of only punctuation\n *\n * NOTE: only has an effect if sentence-level options help.upostag|help.xpostag\n *   are set to true (default: true)\n *\n * @param {Analysis} ana the analysis to evaluate for\n * @param {String} string\n * @return {undefined}\n */\nfunction evaluatePunctPos(ana, string) {\n  if (puncts.test(string)) {\n    if (ana.sentence.options.help.upostag && !ana.upostag) ana.upostag = 'PUNCT';\n\n    if (ana.sentence.options.help.xpostag && !ana.xpostag) ana.xpostag = 'PUNCT';\n  }\n}\n\n/**\n * helper function for Analysis::cg3 [get] ... actually does the work of\n *   deciding how we want to display the information contained in an analysis\n *\n * @param {Analysis} ana\n * @param {Number} tabs current indent level\n * @return {String}\n */\nfunction cg3FormatOutput(analysis, tabs) {\n\n  var indent = new Array(tabs).fill('\\t').join('');\n  var tags = analysis.xpostag ? ' ' + analysis.xpostag.replace(/;/g, ' ') : '';\n  var misc = analysis.misc ? ' ' + analysis.misc.replace(/;/g, ' ') : '';\n  var deprel = analysis.deprel ? ' @' + analysis.deprel : '';\n  var id = analysis.id ? ' #' + analysis.id + '->' : '';\n  var head = id && analysis.head ? '' + analysis.head : '';\n  var dependency = analysis.sentence.options.showEmptyDependencies || analysis.head !== fallback ? '' + id + head : '';\n\n  return indent + '\"' + analysis.lemma + '\"' + tags + misc + deprel + dependency;\n}\n\n// placeholder for CoNLL-U export in `undefined` fields\nvar fallback = '_';\n// setteable fields\nvar fields = [\n// NB: 'id' is not kept here\n'form', 'lemma', 'upostag', 'xpostag', 'feats', 'head', 'deprel', 'deps', 'misc'];\n// supported punctuation characters\nvar puncts = /[.,!?]/;\n\n/**\n * this class contains all the information associated with an analysis, including\n *   a value for each of form, lemma, upostag, xpostag, feats, head, deprel,\n *   deps, & misc ... also keeps an array of subTokens and an index\n */\n\nvar Analysis = function () {\n  function Analysis(token, params) {\n    var _this = this;\n\n    _classCallCheck(this, Analysis);\n\n    // require token param\n    if (!token) throw new NotatrixError('missing required arg: Token');\n\n    // used to make sure we only add the head/deps strings on first pass, since\n    //   we'll eventually call attach() whenever we're constructing like this\n    this.initializing = true;\n\n    // pointers to parents\n    this.token = token;\n    this.sentence = token.sentence;\n\n    // internal arrays of Analyses\n    this._heads = [];\n    this._deps = [];\n\n    // iterate over passed params\n    _.each(params, function (value, key) {\n      if (value === undefined || fields.indexOf(key) === -1) {\n        // delete invalid parameters\n        delete params[key];\n      } else {\n        // save valid ones (using our setters defined below)\n        _this[key] = value;\n      }\n    });\n\n    // save updated params (mostly for debugging purposes)\n    this.params = params || {};\n\n    // internal index (see Sentence::index and Token::index), don't change this!\n    this.id = null;\n\n    // array of Tokens\n    this.subTokens = [];\n\n    // safe to unset this now\n    this.initializing = false;\n  }\n\n  /**\n   * @return {Number} total number of subTokens for this analysis\n   */\n\n\n  _createClass(Analysis, [{\n    key: 'getSubToken',\n\n\n    // manipulate subTokens array\n\n    /**\n     * get subToken at the given index or null\n     *\n     * @param {Number} index\n     * @return {(null|Token)}\n     */\n    value: function getSubToken(index) {\n      return this.subTokens[index] || null;\n    }\n\n    /**\n     * insert a subToken BEFORE the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length), then it will be adjusted\n     *   to fit the bounds. this means that you can call this with `index=-Infinity`\n     *   to push to the front of the subTokens array or with `index=Infinity` to push\n     *   to the end\n     *\n     * @param {Number} index\n     * @param {Token} token\n     * @return {Analysis}\n     *\n     * @throws {NotatrixError} if given invalid index or analysis (see below)\n     */\n\n  }, {\n    key: 'insertSubTokenAt',\n    value: function insertSubTokenAt(index, token) {\n\n      // enforce only indices that can be cast as Numbers\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to insert subToken: unable to cast index to int');\n\n      // enforce token is a Token\n      if (!token) throw new NotatrixError('unable to insert subToken: no subToken provided');\n\n      // enforce token is a Token\n      if (token.__proto__ !== this.token.__proto__) // hacky, but don't have access to Token class\n        throw new NotatrixError('unable to insert subToken: not instance of Token');\n\n      // enforce not trying to add a superToken as a subToken\n      if (token.isSuperToken) throw new NotatrixError('unable to insert subToken: token has subTokens');\n\n      // enforce not trying to add a subToken of some other token\n      if (token.isSubToken) throw new NotatrixError('unable to insert subToken: token is already a subToken');\n\n      // enforce not trying to add a subToken to a subToken\n      if (this.isSubToken) throw new NotatrixError('unable to insert subToken: this is already a subToken');\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.length ? this.length : parseInt(index);\n\n      // set the superToken pointer on the token\n      token.superToken = this;\n\n      // array insertion\n      this.subTokens = this.subTokens.slice(0, index).concat(token).concat(this.subTokens.slice(index));\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * remove a subToken at the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length - 1), then it will be\n     *   adjusted to fit the bounds. this means that you can call this with\n     *   `index=-Infinity` to remove the first element of the subTokens array or\n     *   with `index=Infinity` to remove the last\n     *\n     * @param {Number} index\n     * @return {(null|Token)}\n     *\n     * @throws {NotatrixError} if given invalid index\n     */\n\n  }, {\n    key: 'removeSubTokenAt',\n    value: function removeSubTokenAt(index) {\n      var _this2 = this;\n\n      // can't remove if we have an empty array\n      if (!this.length) return null;\n\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to remove subToken: unable to cast index to int');\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.length - 1 ? this.length - 1 : parseInt(index);\n\n      // unlink heads and deps from the token to be removed\n      this.sentence.forEach(function (token) {\n        token.analysis.eachHead(function (head) {\n          if (head === _this2[index]) token.analysis.removeHead(head);\n        }).eachDep(function (dep) {\n          if (dep === _this2[index]) token.analysis.removeDep(dep);\n        });\n      });\n\n      // remove the superToken pointer from the removed token\n      this.subTokens[index].superToken = null;\n\n      // array splicing, return spliced element\n      return this.subTokens.splice(index, 1)[0];\n    }\n\n    /**\n     * move a subToken from sourceIndex to targetIndex\n     *\n     * NOTE: if either index is out of bounds (<0 or >length - 1), then it will\n     *   be adjusted to fit the bounds. this means that you can call this with\n     *   `sourceIndex=-Infinity` to select the first element of the subTokens array\n     *   or with `sourceIndex=Infinity` to select the last\n     *\n     * @param {Number} sourceIndex\n     * @param {Number} targetIndex\n     * @return {Analysis}\n     *\n     * @throws {NotatrixError} if given invalid sourceIndex or targetIndex\n     */\n\n  }, {\n    key: 'moveSubTokenAt',\n    value: function moveSubTokenAt(sourceIndex, targetIndex) {\n\n      sourceIndex = parseFloat(sourceIndex);\n      targetIndex = parseFloat(targetIndex);\n      if (isNaN(sourceIndex) || isNaN(targetIndex)) throw new NotatrixError('unable to move subToken: unable to cast indices to ints');\n\n      // bounds checking\n      sourceIndex = sourceIndex < 0 ? 0 : sourceIndex > this.length - 1 ? this.length - 1 : parseInt(sourceIndex);\n      targetIndex = targetIndex < 0 ? 0 : targetIndex > this.length - 1 ? this.length - 1 : parseInt(targetIndex);\n\n      if (sourceIndex === targetIndex) {\n        // do nothing\n      } else {\n\n        // array splice and insert\n        var subToken = this.subTokens.splice(sourceIndex, 1);\n        this.subTokens = this.subTokens.slice(0, targetIndex).concat(subToken).concat(this.subTokens.slice(targetIndex));\n      }\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * push a subToken to the end of the subTokens array ... sugar for\n     *   Analysis::insertSubTokenAt(Infinity, analysis)\n     *\n     * @param {Token} token\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'pushSubToken',\n    value: function pushSubToken(token) {\n      return this.insertSubTokenAt(Infinity, token);\n    }\n\n    /**\n     * pop a subToken from the end of the subTokens array ... sugar for\n     *   Analysis::removeSubTokenAt(Infinity)\n     *\n     * @return {(null|Analysis)}\n     */\n\n  }, {\n    key: 'popSubToken',\n    value: function popSubToken() {\n      return this.removeSubTokenAt(Infinity);\n    }\n\n    // external formats\n\n    /**\n     * get a serial version of the internal analysis representation\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'eachHead',\n\n\n    // array-field (heads & deps) manipulators\n\n    /**\n     * iterate over the `head`s for this analysis and apply a callback to each\n     *\n     * @param {Function} callback\n     * @return {Analysis}\n     */\n    value: function eachHead(callback) {\n      _.each(this._heads, function (head, i) {\n        callback(head.token, head.deprel, i);\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * add a head on the given token with a dependency relation\n     *\n     * @param {Analysis} head pointer directly to the analysis\n     * @param {String} deprel\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'addHead',\n    value: function addHead(head, deprel) {\n      if (!(head instanceof Analysis)) throw new NotatrixError('can\\'t add head: not Analysis instance');\n\n      // first try to change an existing one (don't want duplicate heads)\n      if (this.changeHead(head, deprel)) return this;\n\n      // get rid of \"empty\" value\n      if (this._heads.length === 1 && this._heads[0].token === '_') this._heads = [];\n\n      // otherwise push a new one\n      this._heads.push({\n        token: head,\n        deprel: deprel\n      });\n\n      // if applicable, add to the head's deps field too\n      if (this.sentence.options.help.head) head._deps.push({\n        token: this,\n        deprel: deprel\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * remove a head from the given analysis if it exists\n     *\n     * @param {Analysis} head\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'removeHead',\n    value: function removeHead(head) {\n      var _this3 = this;\n\n      if (!(head instanceof Analysis)) throw new NotatrixError('can\\'t remove head: not Analysis instance');\n\n      // remove from _heads\n      var removing = -1;\n      this.eachHead(function (token, deprel, i) {\n        if (token === head) removing = i;\n      });\n      if (removing > -1) this._heads.splice(removing, 1);\n\n      // if applicable, also remove from head's _deps\n      removing = -1;\n      if (this.sentence.options.help.head) head.eachDep(function (token, deprel, i) {\n        if (token === _this3) removing = i;\n      });\n      if (removing > -1) head._deps.splice(removing, 1);\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * change the dependency relation for a given head ... returns null if unable\n     *   to make the change\n     *\n     * @param {Analysis} head\n     * @param {String} deprel\n     * @return {(Analysis|null)}\n     */\n\n  }, {\n    key: 'changeHead',\n    value: function changeHead(head, deprel) {\n      var _this4 = this;\n\n      if (!(head instanceof Analysis)) throw new NotatrixError('can\\'t change head: not Analysis instance');\n\n      // change for this head\n      var done = false;\n      this.eachHead(function (token, _deprel, i) {\n        if (token === head) {\n          _this4._heads[i].deprel = deprel || _deprel;\n          done = true;\n        }\n      });\n\n      // if applicable, change for the head's dep too\n      if (this.sentence.options.help.head) head.eachDep(function (token, _deprel, i) {\n        if (token === _this4) head._deps[i].deprel = deprel || _deprel;\n      });\n\n      return done ? this : null;\n    }\n\n    /**\n     * iterate over the `deps`s for this analysis and apply a callback to each\n     *\n     * @param {Function} callback\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'eachDep',\n    value: function eachDep(callback) {\n      _.each(this._deps, function (dep, i) {\n        callback(dep.token, dep.deprel, i);\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * add a dep on the given token with a dependency relation\n     *\n     * @param {Analysis} dep pointer directly to the analysis\n     * @param {String} deprel\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'addDep',\n    value: function addDep(dep, deprel) {\n      if (!(dep instanceof Analysis)) throw new NotatrixError('can\\'t add dep: not Analysis instance');\n\n      // first try to change an existing one (don't want duplicate deps)\n      if (this.changeDep(dep, deprel)) return this;\n\n      // get rid of \"empty\" value\n      if (this._deps.length === 1 && this._deps[0].token === '_') this._deps = [];\n\n      // otherwise push a new one\n      this._deps.push({\n        token: dep,\n        deprel: deprel\n      });\n\n      // if applicable, add to the dep's head field too\n      if (this.sentence.options.help.deps) dep._heads.push({\n        token: this,\n        deprel: deprel\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * remove a dep from the given analysis if it exists\n     *\n     * @param {Analysis} dep\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'removeDep',\n    value: function removeDep(dep) {\n      var _this5 = this;\n\n      if (!(dep instanceof Analysis)) throw new NotatrixError('can\\'t remove dep: not Analysis instance');\n\n      // remove from _deps\n      var removing = -1;\n      this.eachDep(function (token, deprel, i) {\n        if (token === dep) removing = i;\n      });\n      if (removing > -1) this._deps.splice(removing, 1);\n\n      // if applicable, also remove from dep's _heads\n      removing = -1;\n      if (this.sentence.options.help.deps) dep.eachHead(function (token, deprel, i) {\n        if (token === _this5) removing = i;\n      });\n      if (removing > -1) dep._heads.splice(removing, 1);\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * change the dependency relation for a given dep ... returns null if unable\n     *   to make the change\n     *\n     * @param {Analysis} dep\n     * @param {String} deprel\n     * @return {(Analysis|null)}\n     */\n\n  }, {\n    key: 'changeDep',\n    value: function changeDep(dep, deprel) {\n      var _this6 = this;\n\n      if (!(dep instanceof Analysis)) throw new NotatrixError('can\\'t change dep: not Analysis instance');\n\n      // change for this dep\n      var done = false;\n      this.eachDep(function (token, _deprel, i) {\n        if (token === dep) {\n          _this6._deps[i].deprel = deprel || _deprel;\n          done = true;\n        }\n      });\n\n      // if applicable, change for the dep's head too\n      if (this.sentence.options.help.deps) dep.eachHead(function (token, _deprel, i) {\n        if (token === _this6) dep._heads[i].deprel = deprel || _deprel;\n      });\n\n      return done ? this : null;\n    }\n\n    // field getters and setters\n\n    /**\n     * get the `form` ... if none defined, `help.form` setting `= true` (default:\n     *   `true`), and `lemma` is set, return `lemma` instead\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.subTokens.length;\n    }\n  }, {\n    key: 'nx',\n    get: function get() {\n      var _this7 = this;\n\n      // serialize \"values\" (getter/setter version of fields)\n      var values = {};\n      _.each(fields, function (field) {\n        values[field] = _this7[field];\n      });\n\n      // serialize other data\n      return {\n        id: this.id,\n        num: this.num,\n        params: this.params,\n        values: values,\n        subTokens: this.subTokens.map(function (subToken) {\n          return subToken.nx;\n        })\n      };\n    }\n\n    /**\n     * get a plain-text formatted string of the analysis\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n\n      // first check if we have a form\n      if (this.form && this.form !== fallback) return this.form;\n\n      // fall back to using lemma\n      if (this.lemma && this.lemma !== fallback) return this.lemma;\n\n      // if set, fall back to our fallback (defined above)\n      if (this.sentence.fallbackOnText) return fallback;\n\n      // otherwise just give an empty string\n      return '';\n    }\n\n    /**\n     * get a CoNLL-U formatted string representing the analysis\n     *\n     * @return {String}\n     *\n     * @throws {NotatrixError} if id has not been set\n     */\n\n  }, {\n    key: 'conllu',\n    get: function get() {\n      var _this8 = this;\n\n      // reindex just in case since this is crucial\n      this.sentence.index();\n\n      // we can't output CoNLL-U for analyses that aren't indexed, since that\n      //   means they're not in the current analysis\n      if (this.id === null || this.id === undefined) throw new NotatrixError('analysis is not currently indexed');\n\n      // return a tab-delimited string with the information contained in each field\n      //   and the index out front\n      return this.id + '\\t' + _.map(fields, function (field) {\n\n        // if we have no data for a field, use our fallback to maintain\n        //   the correct matrix structure\n        return _this8[field] || fallback;\n      }).join('\\t');\n    }\n\n    /**\n     * get a CG3 formatted string representing the analysis\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'cg3',\n    get: function get() {\n\n      // reindex just in case since this is crucial\n      this.sentence.index();\n\n      // either output this analysis or its subTokens\n      if (this.isSuperToken) {\n        return this.subTokens.map(function (subToken, i) {\n\n          // recall subTokens get hanging indents\n          return cg3FormatOutput(subToken.analysis, i + 1);\n        }).join('\\n');\n      } else {\n\n        // regular tokens get an index of 1\n        return cg3FormatOutput(this, 1);\n      }\n    }\n\n    /**\n     * get an array of nodes relating to this analysis for export to an external\n     *   graphing library (e.g. Cytoscape, D3)\n     *\n     * @return {Array}\n     */\n\n  }, {\n    key: 'eles',\n    get: function get() {\n      var _this9 = this;\n\n      var eles = [];\n\n      if (this.isCurrent) {\n\n        if (this.isSuperToken) {\n\n          eles.push({ // multiword label\n            data: {\n              id: 'multiword-' + this.id,\n              num: this.num,\n              clump: this.clump,\n              name: 'multiword',\n              label: this.form + ' ' + toSubscript(this.id)\n              /*length: `${this.form.length > 3\n                ? this.form.length * 0.7\n                : this.form.length}em`*/\n            },\n            classes: 'multiword' /*, {\n                                 } */ });\n\n          _.each(this.subTokens, function (subToken) {\n            eles = eles.concat(subToken.eles);\n          });\n        } else {\n\n          eles.push({ // \"number\" node\n            data: {\n              id: 'num-' + this.id,\n              num: this.num,\n              clump: this.clump,\n              name: 'number',\n              label: this.id,\n              pos: this.pos,\n              parent: this.superToken ? 'multiword-' + this.superToken.id : undefined,\n              analysis: this\n            },\n            classes: 'number'\n          }, { // \"form\" node\n            data: {\n              id: 'form-' + this.id,\n              num: this.num,\n              clump: this.clump,\n              name: 'form',\n              attr: 'form',\n              form: this.form,\n              label: this.form,\n              length: (this.form.length > 3 ? this.form.length * 0.7 : this.form.length) + 'em',\n              state: 'normal',\n              parent: 'num-' + this.id,\n              analysis: this\n            },\n            classes: 'form' + (this.head == 0 ? ' root' : '')\n          }, { // \"pos\" node\n            data: {\n              id: 'pos-node-' + this.id,\n              num: this.num,\n              clump: this.clump,\n              name: 'pos-node',\n              attr: 'upostag',\n              label: this.pos || '',\n              length: (this.pos || '').length * 0.7 + 1 + 'em',\n              analysis: this\n            },\n            classes: 'pos'\n          }, { // \"pos\" edge\n            data: {\n              id: 'pos-edge-' + this.id,\n              num: this.num,\n              clump: this.clump,\n              name: 'pos-edge',\n              source: 'form-' + this.id,\n              target: 'pos-node-' + this.id\n            },\n            classes: 'pos'\n          });\n\n          this.eachHead(function (head, deprel) {\n            deprel = deprel || '';\n\n            if (!head || !head.id) // ROOT\n              return;\n\n            eles.push({\n              data: {\n                id: 'dep_' + _this9.id + '_' + head.id,\n                name: 'dependency',\n                attr: 'deprel',\n                source: 'form-' + _this9.id,\n                sourceAnalysis: _this9,\n                target: 'form-' + head.id,\n                targetAnalysis: head,\n                length: deprel.length / 3 + 'em',\n                label: null, // NB overwrite this before use\n                ctrl: null // NB overwrite this before use\n              },\n              classes: null // NB overwrite this before use\n            });\n          });\n        }\n      }\n\n      return eles;\n    }\n  }, {\n    key: 'form',\n    get: function get() {\n      return this.sentence.options.help.form ? this._form || this._lemma : this._form;\n    }\n\n    /**\n     * set the `form` ... if the form is just punctuation, possibly set the pos tags\n     *   to `PUNCT` (see {@link evaluatePunctPos})\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(form) {\n      form = sanitize(form);\n      evaluatePunctPos(this, form);\n      this._form = form;\n    }\n\n    /**\n     * get the `lemma` ... if none defined, `help.lemma` setting `= true` (default:\n     *   `true`), and `form` is set, return `form` instead\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'lemma',\n    get: function get() {\n      return this.isSuperToken ? null : this.sentence.options.help.lemma ? this._lemma || this._form : this._lemma;\n    }\n\n    /**\n     * set the `lemma` ... if the lemma is just punctuation, possibly set the pos tags\n     *   to `PUNCT` (see {@link evaluatePunctPos})\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(lemma) {\n      lemma = sanitize(lemma);\n      evaluatePunctPos(this, lemma);\n      this._lemma = lemma;\n    }\n\n    /**\n     * get the `pos`, which is just `upostag || xpostag`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'pos',\n    get: function get() {\n      return this.upostag || this.xpostag;\n    }\n\n    /**\n     * get the `upostag`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'upostag',\n    get: function get() {\n      return this.isSuperToken ? null : this._upostag;\n    }\n\n    /**\n     * set the `upostag`\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(upostag) {\n      this._upostag = sanitize(upostag);\n    }\n\n    /**\n     * get the `xpostag`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'xpostag',\n    get: function get() {\n      return this.isSuperToken ? null : this._xpostag;\n    }\n\n    /**\n     * set the `xpostag`\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(xpostag) {\n      this._xpostag = sanitize(xpostag);\n    }\n\n    /**\n     * get the `feats`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'feats',\n    get: function get() {\n      return this.isSuperToken ? null : this._feats;\n    }\n\n    /**\n     * set the `feats`\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(feats) {\n      this._feats = sanitize(feats);\n    }\n\n    /**\n     * get the `head` ... if the `showEnhanced` setting `= true` (default: `true`)\n     *   will return a `|`-delimited list of `index`:`deprel` pairs\n     *\n     * @return {(String)}\n     */\n\n  }, {\n    key: 'head',\n    get: function get() {\n      var _this10 = this;\n\n      if (this.isSuperToken) return null;\n\n      if (this.sentence.options.showEnhanced) {\n        var heads = [];\n        this.eachHead(function (token, deprel) {\n          if (token === _this10.sentence.getById(token.id) || !_this10.sentence.options.help.head) {\n            heads.push('' + (token.id || token) + (deprel ? ':' + deprel : ''));\n          } else {\n            heads.push('' + token + (deprel ? ':' + deprel : ''));\n          }\n        });\n        return heads.join('|') || fallback;\n      } else {\n        return this._heads.length ? this._heads[0].id || this._heads[0] : fallback;\n      }\n    }\n\n    /**\n     * set the `head` ... if the `Analysis` is `initializing`, just save a plain\n     *   string, otherwise try to get the head by index (see {@link Sentence#getById})\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(heads) {\n      var _this11 = this;\n\n      heads = heads || [];\n      if (typeof heads === 'string') heads = parseEnhancedString(heads);\n\n      this._heads = heads.map(function (head) {\n        return _this11.initializing ? {\n          token: head.token,\n          deprel: head.deprel\n        } : {\n          token: _this11.sentence.getById(head.token) || head.token,\n          deprel: head.deprel\n        };\n      }).filter(function (head) {\n        if (head.token !== fallback) return head;\n      });\n    }\n\n    /**\n     * get the `deprel`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'deprel',\n    get: function get() {\n      return this.isSuperToken ? null : this._deprel;\n    }\n\n    /**\n     * set the `deprel`\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(deprel) {\n      this._deprel = sanitize(deprel);\n    }\n\n    /**\n     * get the `deps` returns a `|`-delimited list of `index`:`deprel` pairs\n     *\n     * @return {(String)}\n     */\n\n  }, {\n    key: 'deps',\n    get: function get() {\n      var _this12 = this;\n\n      if (this.isSuperToken) return null;\n\n      // don't worry about enhanced stuff for deps (always can be multiple)\n      var deps = [];\n      this.eachDep(function (token, deprel) {\n        if (token === _this12.sentence.getById(token.id) || !_this12.sentence.options.help.deps) {\n          deps.push('' + (token.id || token) + (deprel ? ':' + deprel : ''));\n        } else {\n          deps.push('' + token + (deprel ? ':' + deprel : ''));\n        }\n      });\n      return deps.join('|') || fallback;\n    }\n\n    /**\n     * set the `deps` ... if the `Analysis` is `initializing`, just save a plain\n     *   string, otherwise try to get the dep by index (see {@link Sentence#getById})\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(deps) {\n      var _this13 = this;\n\n      deps = deps || [];\n      if (typeof deps === 'string') deps = parseEnhancedString(deps);\n\n      this._deps = deps.map(function (dep) {\n        return _this13.initializing ? {\n          token: dep.token,\n          deprel: dep.deprel\n        } : {\n          token: _this13.sentence.getById(dep.token) || dep.token,\n          deprel: dep.deprel\n        };\n      }).filter(function (dep) {\n        if (dep.token !== fallback) return dep;\n      });\n    }\n\n    /**\n     * get the `misc`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'misc',\n    get: function get() {\n      // superTokens can have \"misc\" field\n      return this._misc;\n    }\n\n    /**\n     * set the `misc`\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(misc) {\n      this._misc = sanitize(misc);\n    }\n\n    // bool stuff\n\n    /**\n     * returns this analysis's superToken if it exists\n     *\n     * @return {(Token|null)}\n     */\n\n  }, {\n    key: 'superToken',\n    get: function get() {\n      return this.token.superToken;\n    }\n\n    /**\n     * returns true iff this analysis is a subToken of some other token\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSubToken',\n    get: function get() {\n      return this.superToken !== null;\n    }\n\n    /**\n     * returns true iff this analysis has subTokens\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSuperToken',\n    get: function get() {\n      return this.subTokens.length > 0;\n    }\n\n    /**\n     * returns true iff this analysis is the current analysis\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCurrent',\n    get: function get() {\n      return this.token.analysis === this;\n    }\n  }]);\n\n  return Analysis;\n}();\n\n/**\n * Proxy so that we can get subTokens using Array-like syntax\n *\n * NOTE: usage: `ana[8]` would return the analysis of the subToken at index 8\n * NOTE: if `name` is not a Number, fall through to normal object\n *\n * @return {Mixed}\n * @name Analysis#get\n */\n\n\nAnalysis.prototype.__proto__ = new Proxy(Analysis.prototype.__proto__, {\n\n  // default getter, called any time we use Analysis.name or Analysis[name]\n  get: function get(target, name, receiver) {\n\n    // Symbols can't be cast to floats, so check here to avoid errors\n    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'symbol') return this[name];\n\n    // cast, catch Infinity\n    var id = parseFloat(name);\n    if (!isNaN(id)) {\n\n      // if we got a number, return analysis of subToken at that index\n      id = parseInt(id);\n      var token = receiver.subTokens[id];\n      return token ? token.analysis : null;\n    } else {\n\n      // fall through to normal getting\n      return this[name];\n    }\n  }\n});\n\n// expose to application\nmodule.exports = Analysis;\n\n},{\"./errors\":3,\"underscore\":1}],3:[function(require,module,exports){\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar NotatrixError = function (_Error) {\n  _inherits(NotatrixError, _Error);\n\n  function NotatrixError() {\n    var _ref;\n\n    _classCallCheck(this, NotatrixError);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _possibleConstructorReturn(this, (_ref = NotatrixError.__proto__ || Object.getPrototypeOf(NotatrixError)).call.apply(_ref, [this].concat(args)));\n  }\n\n  return NotatrixError;\n}(Error);\n\nvar InvalidCG3Error = function (_NotatrixError) {\n  _inherits(InvalidCG3Error, _NotatrixError);\n\n  function InvalidCG3Error() {\n    var _ref2;\n\n    _classCallCheck(this, InvalidCG3Error);\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return _possibleConstructorReturn(this, (_ref2 = InvalidCG3Error.__proto__ || Object.getPrototypeOf(InvalidCG3Error)).call.apply(_ref2, [this].concat(args)));\n  }\n\n  return InvalidCG3Error;\n}(NotatrixError);\n\nvar InvalidCoNLLUError = function (_NotatrixError2) {\n  _inherits(InvalidCoNLLUError, _NotatrixError2);\n\n  function InvalidCoNLLUError() {\n    var _ref3;\n\n    _classCallCheck(this, InvalidCoNLLUError);\n\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return _possibleConstructorReturn(this, (_ref3 = InvalidCoNLLUError.__proto__ || Object.getPrototypeOf(InvalidCoNLLUError)).call.apply(_ref3, [this].concat(args)));\n  }\n\n  return InvalidCoNLLUError;\n}(NotatrixError);\n\nvar TransformationError = function (_NotatrixError3) {\n  _inherits(TransformationError, _NotatrixError3);\n\n  function TransformationError() {\n    var _ref4;\n\n    _classCallCheck(this, TransformationError);\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return _possibleConstructorReturn(this, (_ref4 = TransformationError.__proto__ || Object.getPrototypeOf(TransformationError)).call.apply(_ref4, [this].concat(args)));\n  }\n\n  return TransformationError;\n}(NotatrixError);\n\nmodule.exports = {\n\n  NotatrixError: NotatrixError,\n  InvalidCG3Error: InvalidCG3Error,\n  InvalidCoNLLUError: InvalidCoNLLUError,\n  TransformationError: TransformationError\n\n};\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  Error: require('./errors'),\n  Sentence: require('./sentence'),\n  Token: require('./token'),\n  Analysis: require('./analysis')\n\n};\n\n},{\"./analysis\":2,\"./errors\":3,\"./sentence\":5,\"./token\":6}],5:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _ = require('underscore');\n\nvar NotatrixError = require('./errors').NotatrixError;\nvar InvalidCG3Error = require('./errors').InvalidCG3Error;\nvar InvalidCoNLLUError = require('./errors').InvalidCoNLLUError;\n\nvar Token = require('./token');\nvar Analysis = require('./analysis');\n\n// define all the regex we use in this module here\nvar regex = {\n  comment: /^\\W*\\#/,\n  commentContent: /^\\W*\\#\\W*(.*)/,\n  superToken: /^\\W*[0-9.]+\\-[0-9.]+/,\n  empty: /^\\W*[0-9]+\\.[0-9]+/,\n  cg3TokenStart: /^\"<(.|\\\\\")*>\"/,\n  cg3TokenContent: /^;?\\s+\"(.|\\\\\")*\"/\n\n  /**\n   * this class contains all the information associated with a sentence, including\n   *   an comments array, a tokens array, and a list of options/settings that apply\n   *   to all subelements of this sentence\n   */\n};\nvar Sentence = function () {\n  function Sentence(paramsList, options) {\n    _classCallCheck(this, Sentence);\n\n    // handle only receiving one arg better\n    if (options === undefined && !Array.isArray(paramsList)) {\n      options = paramsList;\n      paramsList = undefined;\n    }\n\n    // save sentence-wide settings here\n    this.options = _.defaults(options, {\n      help: {\n        form: true,\n        lemma: true,\n        upostag: true,\n        xpostag: true,\n        head: true,\n        deps: true\n      },\n      prettyOutput: true,\n      showEnhanced: true,\n      showEmptyDependencies: true,\n      catchInvalid: true,\n      fallbackOnText: false\n    });\n\n    // the actual data\n    this.comments = [];\n    this.tokens = [];\n\n    // try parsing a list of parameters\n    if (paramsList) this.params = paramsList;\n  }\n  /**\n   * @return {Number} total number of tokens/subTokens in this sentence\n   */\n\n\n  _createClass(Sentence, [{\n    key: 'forEach',\n\n    /**\n     * loop through every token in the sentence and apply a callback\n     *\n     * @param {Function} callback function to be applied to every token\n     * @return {Sentence}\n     */\n    value: function forEach(callback) {\n\n      var t = 0;\n      for (var i = 0; i < this.tokens.length; i++) {\n        var token = this.tokens[i];\n        callback(token, t);\n        t++;\n        for (var j = 0; j < token.subTokens.length; j++) {\n          callback(token.subTokens[j], t);\n          t++;\n        }\n      }\n\n      // chaining\n      return this;\n    }\n    /**\n     * loop through the tokens in the sentence and return the superToken and\n     *   subToken indices\n     * @param {Token} tok token to search for\n     * @return {(Object|null)}\n     */\n\n  }, {\n    key: 'getIndices',\n    value: function getIndices(tok) {\n\n      var superTokenId = -1,\n          subTokenId = -1,\n          analysisId = 0,\n          found = false,\n          isSubToken = false;\n\n      tok.sentence.forEach(function (token) {\n\n        if (found) return;\n\n        if (token.isSubToken) {\n          subTokenId++;\n          isSubToken = true;\n        } else {\n          superTokenId++;\n          subTokenId = -1;\n          isSubToken = false;\n        }\n\n        if (token === tok) found = true;\n      });\n\n      return superTokenId === -1 ? null : {\n        super: superTokenId,\n        sub: isSubToken ? subTokenId : null\n      };\n    }\n\n    /**\n     * return the comment at the given index, or null\n     *\n     * @param {Number} index\n     * @return {(String|null)}\n     */\n\n  }, {\n    key: 'getComment',\n    value: function getComment(index) {\n      return this.comments[index] || null;\n    }\n\n    /**\n     * return the token at the given index (note: this is regular token OR subToken),\n     *   or null.  to choose by superToken index, use Sentence[index] syntax.  this\n     *   function assumes only the current analysis is desired.\n     *\n     * @param {Number} index\n     * @return {(Token|null)}\n     */\n\n  }, {\n    key: 'getToken',\n    value: function getToken(index) {\n      var t = 0,\n          token = null;\n      this.forEach(function (tok, t) {\n        if (t === index) token = tok;\n      });\n      return token;\n    }\n\n    /**\n     * return the current analysis of the token that matches a given index string\n     *\n     * NOTE: tokens outside the current analysis will have id=null and cannot be retrieved\n     *   with this function\n     *\n     * @param {String} index\n     * @return {(Analysis|null)}\n     */\n\n  }, {\n    key: 'getById',\n    value: function getById(index) {\n      for (var i = 0; i < this.tokens.length; i++) {\n        var token = this.tokens[i];\n        if (token.analysis.id == index) return token.analysis;\n        for (var j = 0; j < token.subTokens.length; j++) {\n          var subToken = token.subTokens[j];\n          if (subToken.analysis.id == index) return subToken.analysis;\n        }\n      }\n      return null;\n    }\n\n    // manipulate token array\n\n    /**\n     * insert a token AFTER the given token\n     *\n     * NOTE: if only passed 1 arg, it will insert a token constructed from\n     *   the params { form: 'inserted' }\n     *\n     * @param {Token} atToken\n     * @param {(Token|null)} newToken\n     * @return {Sentence}\n     *\n     * @throws {NotatrixError} if given invalid token for first param\n     */\n\n  }, {\n    key: 'insertTokenBefore',\n    value: function insertTokenBefore(atToken, newToken) {\n\n      if (!(atToken instanceof Token)) throw new NotatrixError('unable to insert token: not instance of Token');\n\n      if (!(newToken instanceof Token)) newToken = Token.fromParams(this, { form: 'inserted' });\n\n      var indices = this.getIndices(atToken);\n      if (indices === null) return null;\n\n      return indices.sub === null ? this.insertTokenAt(indices.super, newToken) : this[indices.super].insertSubTokenAt(indices.sub, newToken);\n    }\n\n    /**\n     * insert a token AFTER the given token\n     *\n     * NOTE: if only passed 1 arg, it will insert a token constructed from\n     *   the params { form: 'inserted' }\n     *\n     * @param {Token} atToken\n     * @param {(Token|null)} newToken\n     * @return {Sentence}\n     *\n     * @throws {NotatrixError} if given invalid token for first param\n     */\n\n  }, {\n    key: 'insertTokenAfter',\n    value: function insertTokenAfter(atToken, newToken) {\n\n      if (!(atToken instanceof Token)) throw new NotatrixError('unable to insert token: not instance of Token');\n\n      if (!(newToken instanceof Token)) newToken = Token.fromParams(this, { form: 'inserted' });\n\n      var indices = this.getIndices(atToken);\n      if (indices === null) return null;\n\n      return indices.sub === null ? this.insertTokenAt(indices.super + 1, newToken) : this[indices.super].insertSubTokenAt(indices.sub + 1, newToken);\n    }\n\n    /**\n     * insert an analysis BEFORE the given analysis\n     *\n     * NOTE: if only passed 1 arg, it will insert an analysis constructed from\n     *   the params { form: 'inserted' }\n     *\n     * @param {Analysis} atAnalysis\n     * @param {(Analysis|null)} newAnalysis\n     * @return {Sentence}\n     *\n     * @throws {NotatrixError} if given invalid analysis for first param\n     */\n\n  }, {\n    key: 'insertAnalysisBefore',\n    value: function insertAnalysisBefore(atAnalysis, newAnalysis) {\n\n      if (!(atAnalysis instanceof Analysis)) throw new NotatrixError('unable to insert analysis: not instance of Analysis');\n\n      if (!(newAnalysis instanceof Analysis)) newAnalysis = Token.fromParams(this, { form: 'inserted' }).analysis;\n\n      var indices = this.getIndices(atAnalysis.token);\n      if (indices === null) return null;\n\n      var token = indices.sub === null ? this[indices.super].token : this[indices.super][indices.sub].token;\n\n      var analysisId = -1;\n      token.forEach(function (ana, i) {\n        if (ana === atAnalysis) analysisId = i;\n      });\n\n      if (analysisId > -1) return token.insertAnalysisAt(analysisId, newAnalysis);\n    }\n\n    /**\n     * insert an analysis AFTER the given analysis\n     *\n     * NOTE: if only passed 1 arg, it will insert an analysis constructed from\n     *   the params { form: 'inserted' }\n     *\n     * @param {Analysis} atAnalysis\n     * @param {(Analysis|null)} newAnalysis\n     * @return {Sentence}\n     *\n     * @throws {NotatrixError} if given invalid analysis for first param\n     */\n\n  }, {\n    key: 'insertAnalysisAfter',\n    value: function insertAnalysisAfter(atAnalysis, newAnalysis) {\n\n      if (!(atAnalysis instanceof Analysis)) throw new NotatrixError('unable to insert analysis: not instance of Analysis');\n\n      if (!(newAnalysis instanceof Analysis)) newAnalysis = Token.fromParams(this, { form: 'inserted' }).analysis;\n\n      var indices = this.getIndices(atAnalysis.token);\n      if (indices === null) return null;\n\n      var token = indices.sub === null ? this[indices.super].token : this[indices.super][indices.sub].token;\n\n      var analysisId = -1;\n      token.forEach(function (ana, i) {\n        if (ana === atAnalysis) analysisId = i;\n      });\n\n      if (analysisId > -1) return token.insertAnalysisAt(analysisId + 1, newAnalysis);\n    }\n\n    /**\n     * insert a token BEFORE the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length), then it will be adjusted\n     *   to fit the bounds. this means that you can call this with `index=-Infinity`\n     *   to push to the front of the tokens array or with `index=Infinity` to push\n     *   to the end\n     *\n     * @param {Number} index\n     * @param {Token} token\n     * @return {Sentence}\n     *\n     * @throws {NotatrixError} if given invalid index or token\n     */\n\n  }, {\n    key: 'insertTokenAt',\n    value: function insertTokenAt(index, token) {\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to insert token: unable to cast index to int');\n\n      if (!(token instanceof Token)) throw new NotatrixError('unable to insert token: not instance of Token');\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.length ? this.length : parseInt(index);\n\n      // array insertion\n      this.tokens = this.tokens.slice(0, index).concat(token).concat(this.tokens.slice(index));\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * remove a token at the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length - 1), then it will be\n     *   adjusted to fit the bounds. this means that you can call this with\n     *   `index=-Infinity` to remove the first element of the tokens array or\n     *   with `index=Infinity` to remove the last\n     *\n     * @param {Number} index\n     * @return {(Token|null)}\n     *\n     * @throws {NotatrixError} if given invalid index\n     */\n\n  }, {\n    key: 'removeTokenAt',\n    value: function removeTokenAt(index) {\n      var _this = this;\n\n      // can't remove if we have an empty sentence\n      if (!this.tokens.length) return null;\n\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to remove token: unable to cast index to int');\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.tokens.length - 1 ? this.tokens.length - 1 : parseInt(index);\n\n      // unlink heads and deps from the token to be removed\n      this.forEach(function (token) {\n        token.analysis.eachHead(function (head) {\n          if (head === _this[index]) token.analysis.removeHead(head);\n        }).eachDep(function (dep) {\n          if (dep === _this[index]) token.analysis.removeDep(dep);\n        });\n      });\n\n      // array splicing, return spliced element\n      return this.tokens.splice(index, 1)[0];\n    }\n\n    /**\n     * move a token from sourceIndex to targetIndex\n     *\n     * NOTE: if either index is out of bounds (<0 or >length - 1), then it will\n     *   be adjusted to fit the bounds. this means that you can call this with\n     *   `sourceIndex=-Infinity` to select the first element of the tokens array\n     *   or with `sourceIndex=Infinity` to select the last\n     *\n     * @param {Number} sourceIndex\n     * @param {Number} targetIndex\n     * @return {Sentence}\n     *\n     * @throws {NotatrixError} if given invalid sourceIndex or targetIndex\n     */\n\n  }, {\n    key: 'moveTokenAt',\n    value: function moveTokenAt(sourceIndex, targetIndex) {\n      sourceIndex = parseFloat(sourceIndex);\n      targetIndex = parseFloat(targetIndex);\n      if (isNaN(sourceIndex) || isNaN(targetIndex)) throw new NotatrixError('unable to move token: unable to cast indices to ints');\n\n      // bounds checking\n      sourceIndex = sourceIndex < 0 ? 0 : sourceIndex > this.tokens.length - 1 ? this.tokens.length - 1 : parseInt(sourceIndex);\n      targetIndex = targetIndex < 0 ? 0 : targetIndex > this.tokens.length - 1 ? this.tokens.length - 1 : parseInt(targetIndex);\n\n      if (sourceIndex === targetIndex) {\n        // do nothing\n      } else {\n\n        // array splice and insert\n        var token = this.tokens.splice(sourceIndex, 1);\n        this.tokens = this.tokens.slice(0, targetIndex).concat(token).concat(this.tokens.slice(targetIndex));\n      }\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * push a token to the end of the tokens array ... sugar for\n     *   Sentence::insertTokenAt(Infinity, token)\n     *\n     * @param {Token} token\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'pushToken',\n    value: function pushToken(token) {\n      return this.insertTokenAt(Infinity, token);\n    }\n\n    /**\n     * pop a token from the end of the tokens array ... sugar for\n     *   Sentence::removeTokenAt(Infinity)\n     *\n     * @return {(Token|null)}\n     */\n\n  }, {\n    key: 'popToken',\n    value: function popToken() {\n      return this.removeTokenAt(Infinity);\n    }\n\n    // external formats\n\n    /**\n     * get a serial version of the internal sentence representation\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'clean',\n    value: function clean() {\n      throw new Error('Sentence::clean is not implemented'); // TODO\n    }\n\n    /**\n     * iterate through the tokens and set an appropriate index for each (following\n     *   CoNLL-U indexing scheme with, e.g. 1 for regular token, 1-2 for superToken,\n     *   1.1 for \"empty\" token)\n     *\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'index',\n    value: function index() {\n      // track \"overall\" index number (id) and \"empty\" index number and \"absolute\" num\n      // NOTE: CoNLL-U indices start at 1 (0 is root), so we will increment this\n      //   index before using it (see Token::index)\n      var id = 0,\n          empty = 0,\n          num = 0,\n          clump = 0;\n      _.each(this.tokens, function (token) {\n        var _token$index = token.index(id, empty, num, clump);\n        // allow each token to return counters for the next guy\n\n\n        var _token$index2 = _slicedToArray(_token$index, 4);\n\n        id = _token$index2[0];\n        empty = _token$index2[1];\n        num = _token$index2[2];\n        clump = _token$index2[3];\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * iterate through the tokens and try to convert a plain string index to a\n     *   head to the actual token given by that index (called after parsing\n     *   CoNLL-U, CG3, or params)\n     *\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'attach',\n    value: function attach() {\n      // reindex in case we're out of date (valid index is crucial here)\n      this.index();\n      this.forEach(function (token) {\n        token.analysis.head = token.analysis.head;\n        token.analysis.deps = token.analysis.deps;\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * iterate through the tokens and determine if they could be converted into\n     *   a CoNLL-U formatted string\n     *\n     * NOTE: currently, only returns false if it contains one/more ambiguous analyses\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n\n      var acc = 0;\n      this.forEach(function (token) {\n        acc++;\n      });\n      return acc;\n    }\n  }, {\n    key: 'nx',\n    get: function get() {\n      // update indices\n      this.index();\n\n      // serialize tokens\n      var tokens = [];\n      for (var i = 0; i < this.tokens.length; i++) {\n        tokens.push(this.tokens[i].nx);\n      }\n\n      // serialize other data\n      return JSON.stringify({\n        comments: this.comments,\n        options: this.options,\n        tokens: tokens\n      }, null, this.options.prettyOutput ? 2 : 0);\n    }\n\n    /**\n     * get a plain-text formatted string of the sentence's current analysis text\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      // only care about tokens (not comments or settings)\n      var tokens = [];\n      this.forEach(function (token) {\n        if (!token.isSubToken && !token.isEmpty) tokens.push(token.text);\n      });\n      return tokens.join(' ');\n    }\n\n    /**\n     * parse a Plain text formatted string and save its contents to the sentence\n     *\n     * @param {String} text\n     * @return {String}\n     */\n    ,\n    set: function set(text) {\n      var _this2 = this;\n\n      // insert a space before final punctuation\n      text = text.trim().replace(/([.,?!]+)$/, ' $1');\n\n      // split on whitespace and add form-only tokens\n      _.map(text.split(/\\s/), function (chunk) {\n        _this2.pushToken(Token.fromParams(_this2, { form: chunk }));\n      });\n\n      return this.text;\n    }\n\n    /**\n     * static method allowing us to construct a new Sentence directly from a\n     *   text string\n     *\n     * @param {String} serial\n     * @param {Object} options (optional)\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'conllu',\n\n\n    /**\n     * get a CoNLL-U formatted string representing the sentence's current analysis\n     *\n     * @return {(String|null)}\n     */\n    get: function get() {\n      // comments first\n      var comments = _.map(this.comments, function (comment) {\n        return '# ' + comment;\n      });\n\n      try {\n\n        var tokens = [];\n        this.forEach(function (token) {\n          tokens.push(token.conllu);\n        });\n        return comments.concat(tokens).join('\\n');\n      } catch (e) {\n\n        // if the sentence contains ambiguous analyses, we will get an error,\n        // so catch only those types of errors here\n        if (!(e instanceof InvalidCoNLLUError) || !this.options.catchInvalid) throw e;\n\n        // if sentence is ambiguous\n        return null;\n      }\n    }\n\n    /**\n     * parse a CoNLL-U formatted string and save its contents to the sentence\n     *\n     * @param {String} conllu\n     * @return {String}\n     */\n    ,\n    set: function set(conllu) {\n      // clear existing data\n      this.comments = [];\n      this.tokens = [];\n\n      // split on newlines\n      var lines = conllu.trim().split('\\n');\n      for (var i = 0; i < lines.length; i++) {\n\n        // extract comments\n        if (regex.comment.test(lines[i])) {\n          this.comments.push(lines[i].match(regex.commentContent)[1]);\n\n          // extract tokens\n        } else if (regex.superToken.test(lines[i])) {\n\n          // the top-level token\n          var superToken = Token.fromConllu(this, lines[i]);\n\n          // check which subTokens belong to this superToken\n          var k = i;\n          var subTokenIndices = lines[i].match(regex.superToken)[0].trim().split('-').map(function (str) {\n            return parseInt(str);\n          });\n\n          // push them all to the superToken's current analysis\n          for (var j = 0; j <= subTokenIndices[1] - subTokenIndices[0]; j++) {\n            superToken.analysis.pushSubToken(Token.fromConllu(this, lines[j + k + 1]));\n            i++;\n          }\n\n          // push the superToken to the sentence\n          this.pushToken(superToken);\n        } else {\n\n          // regular (non-super) tokens pushed to sentence here\n          if (lines[i].trim().length) this.pushToken(Token.fromConllu(this, lines[i]));\n        }\n      }\n\n      // attach heads and return CoNLL-U string\n      return this.attach().conllu;\n    }\n\n    /**\n     * static method allowing us to construct a new Sentence directly from a\n     *   CoNLL-U string\n     *\n     * @param {String} serial\n     * @param {Object} options (optional)\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'cg3',\n\n\n    /**\n     * get a CG3 formatted string representing all of the sentence's analyses\n     *\n     * @return {(String|null)}\n     */\n    get: function get() {\n      // comments first\n      var comments = _.map(this.comments, function (comment) {\n        return '# ' + comment;\n      });\n\n      try {\n\n        var tokens = [];\n        for (var i = 0; i < this.tokens.length; i++) {\n          // iterate over superTokens\n          tokens.push(this.tokens[i].cg3);\n        }\n        return comments.concat(tokens).join('\\n');\n      } catch (e) {\n\n        // if the sentence is not analyzeable as CG3, we'll get an error\n        // NOTE: this doesn't currently happen under any circumstances\n        if (!(e instanceof InvalidCG3Error) || !this.options.catchInvalid) throw e;\n\n        return null;\n      }\n    }\n\n    /**\n     * parse a CG3 formatted string and save its contents to the sentence\n     *\n     * @param {String} conllu\n     * @return {String}\n     */\n    ,\n    set: function set(cg3) {\n      // clear existing data\n      this.comments = [];\n      this.tokens = [];\n\n      // since this parsing is more complicated than CoNLL-U parsing, keep this\n      //   array of lines for the current token we're parsing\n      // NOTE: CG3 tokens are separated by lines of the form `/^\"<EXAMPLE>\"/`\n      //   and lines beginning with one/more indent give data for that token\n      var tokenLines = [];\n\n      // split on newlines\n      var lines = cg3.trim().split('\\n');\n      for (var i = 0; i < lines.length; i++) {\n\n        // decide what the current line is\n        var isToken = regex.cg3TokenStart.test(lines[i]);\n        var isContent = regex.cg3TokenContent.test(lines[i]);\n\n        // current line is the start of a new token\n        if (isToken) {\n\n          // if we already have stuff in our tokenLines buffer, parse it as a token\n          if (tokenLines.length) this.tokens.push(Token.fromCG3(this, tokenLines));\n\n          // reset tokenLines buffer\n          tokenLines = [lines[i]];\n        } else {\n\n          // add content lines to tokenLines buffer\n          if (tokenLines.length && isContent) {\n            tokenLines.push(lines[i]);\n\n            // push comment\n          } else {\n            this.comments.push(lines[i].match(regex.commentContent)[1]);\n          }\n        }\n      }\n\n      // clear tokenLines buffer\n      if (tokenLines.length) this.tokens.push(Token.fromCG3(this, tokenLines));\n\n      // attach heads and return CG3 string\n      return this.attach().cg3;\n    }\n\n    /**\n     * static method allowing us to construct a new Sentence directly from a\n     *   CG3 string\n     *\n     * @param {String} serial\n     * @param {Object} options (optional)\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'params',\n\n\n    /**\n     * get an array of token parameters representing the sentence\n     *\n     * NOTE: fails (returns null) if we have subTokens or ambiguous analyses\n     *\n     * @return {(Array|null)}\n     */\n    get: function get() {\n      try {\n\n        var params = [];\n        this.forEach(function (token) {\n\n          if (token.isSuperToken || token.isSubToken) throw new InvalidCoNLLUError();\n          if (token.isAmbiguous) throw new InvalidCG3Error();\n\n          params.push(token.params);\n        });\n        return params;\n      } catch (e) {\n        if (e instanceof InvalidCoNLLUError && this.options.catchInvalid) {\n          console.warn('cannot get params for this sentence: contains MultiWordTokens');\n          return null;\n        } else if (e instanceof InvalidCG3Error && this.options.catchInvalid) {\n          console.warn('cannot get params for this sentence: contains ambiguous analyses');\n          return null;\n        } else {\n          // throw other errors\n          throw e;\n        }\n      }\n    }\n\n    /**\n     * parse an array of token parameters and save contents to the sentence\n     *\n     * @param {Array} paramsList\n     * @return {(Array|null)}\n     */\n    ,\n    set: function set(paramsList) {\n      var _this3 = this;\n\n      // can only parse arrays\n      if (!(paramsList instanceof Array)) return null;\n\n      // clear existing data\n      this.comments = [];\n      this.tokens = [];\n\n      // push a new token for each set of parameters\n      _.each(paramsList, function (params) {\n        _this3.tokens.push(Token.fromParams(_this3, params));\n      });\n\n      // attach heads and return validated parameter list\n      return this.attach().params;\n    }\n\n    /**\n     * static method allowing us to construct a new Sentence directly from an\n     *   array of parameters\n     *\n     * @param {Array} paramsList\n     * @param {Object} options (optional)\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'eles',\n\n\n    /**\n     * get an array of the elements of this sentence, useful for exporting the data\n     *   to visualization libraries such as Cytoscape or D3\n     *\n     * @return {Array}\n     */\n    get: function get() {\n\n      // just in case, since it's critical\n      this.index();\n\n      var eles = [];\n      this.forEach(function (token) {\n        eles = eles.concat(token.eles);\n      });\n\n      return eles;\n    }\n  }, {\n    key: 'isValidConllu',\n    get: function get() {\n      var valid = true;\n      this.forEach(function (token) {\n        if (token.isAmbiguous) valid = false;\n      });\n      return valid;\n    }\n\n    /**\n     * iterate through the tokens and determine if they could be converted into\n     *   a CG3 formatted string\n     *\n     * NOTE: currently, always returns true (see update below)\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isValidCG3',\n    get: function get() {\n      var valid = true;\n      this.forEach(function (token) {\n        /*\n        UPDATE 6/9/18: apparently CG3 can handle all this stuff, it's just a bit lossy\n          (e.g. subTokens won't have their own `form` and `empty` tokens won't show up)\n         if (token.isSubToken || token.isSuperToken || token.isEmpty)\n          valid = false;\n        */\n      });\n      return valid;\n    }\n  }], [{\n    key: 'fromText',\n    value: function fromText(serial, options) {\n      var sent = new Sentence(options);\n      sent.text = serial;\n      return sent;\n    }\n  }, {\n    key: 'fromConllu',\n    value: function fromConllu(serial, options) {\n      var sent = new Sentence(options);\n      sent.conllu = serial;\n      return sent;\n    }\n  }, {\n    key: 'fromCG3',\n    value: function fromCG3(serial, options) {\n      var sent = new Sentence(options);\n      sent.cg3 = serial;\n      return sent;\n    }\n  }, {\n    key: 'fromParams',\n    value: function fromParams(paramsList, options) {\n      var sent = new Sentence(options);\n      sent.params = paramsList;\n      return sent;\n    }\n  }]);\n\n  return Sentence;\n}();\n\n/**\n * Proxy so that we can get tokens using Array-like syntax\n *\n * NOTE: usage: `sent[8]` would return the analysis of the token at index 8\n * NOTE: if `name` is not a Number, fall through to normal object\n *\n * @return {Mixed}\n * @name Sentence#get\n */\n\n\nSentence.prototype.__proto__ = new Proxy(Sentence.prototype.__proto__, {\n\n  // default getter, called any time we use Sentence.name or Sentence[name]\n  get: function get(target, name, receiver) {\n\n    // Symbols can't be cast to floats, so check here to avoid errors\n    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'symbol') return this[name];\n\n    // cast, catch Infinity\n    var id = parseFloat(name);\n    if (!isNaN(id)) {\n\n      // if we got a number, return analysis at that index\n      id = parseInt(id);\n      var token = receiver.tokens[id];\n      return token ? token.analysis : null;\n    } else {\n\n      // fall through to normal getting\n      return this[name];\n    }\n  }\n});\n\n// expose to application\nmodule.exports = Sentence;\n\n},{\"./analysis\":2,\"./errors\":3,\"./token\":6,\"underscore\":1}],6:[function(require,module,exports){\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _ = require('underscore');\n\nvar NotatrixError = require('./errors').NotatrixError;\nvar InvalidCG3Error = require('./errors').InvalidCG3Error;\nvar InvalidCoNLLUError = require('./errors').InvalidCoNLLUError;\n\nvar Analysis = require('./analysis');\n\n/**\n * helper function to split on whitespace\n *\n * @param {String} str\n * @return {Array}\n */\nfunction split(str) {\n  return (str || '').split(/\\s+/);\n}\n\n/**\n * helper function to count the number of leading `\\t` characters in a string\n *\n * @param {String} line\n * @return {Number}\n */\nfunction getIndent(line) {\n\n  var chars = line.split(''),\n      i = 0;\n\n  while (chars[i++] === '\\t') {\n    true;\n  } // do nothing\n\n  return i - 1;\n}\n\n// CG3 parser helper functions\n\n/**\n * extract the `form` parameter from a given string\n *\n * @param {String} line\n * @return {(undefined|String)}\n */\nfunction cg3StringGetForm(line) {\n\n  return cg3Regex.form.test(line) ? line.match(cg3Regex.form)[1] : undefined;\n}\n\n/**\n * extract all the other (not `form`) tags from a given string\n *\n * @param {String} line\n * @return {Object}\n */\nfunction cg3StringGetTags(line) {\n\n  // initialize things\n  var lemma = void 0,\n      xpostag = [],\n      head = void 0,\n      deprel = void 0,\n      deps = void 0,\n      misc = [];\n\n  // get lemma\n  if (cg3Regex.lemma.test(line)) lemma = line.match(cg3Regex.lemma)[1];\n\n  // only consider line after lemma (if it exists)\n  line = lemma ? line.slice(line.indexOf(lemma) + lemma.length + 1).trim() : line;\n\n  // split on whitespace\n  var chunks = split(line);\n\n  // iterate over each chunk\n  for (var j = 0; j < chunks.length; j++) {\n\n    // try to extract deprel\n    if (cg3Regex.deprel.test(chunks[j])) {\n      deprel = chunks[j].match(cg3Regex.deprel)[1];\n\n      // try to extract head\n    } else if (cg3Regex.dependency.test(chunks[j])) {\n      head = chunks[j].match(cg3Regex.dependency)[2];\n\n      // try to extract misc, track with array (can be multiple)\n    } else if (cg3Regex.misc.test(chunks[j])) {\n      misc.push(chunks[j]);\n\n      // try to extract tags (and save to xpostag), track with an array (can be multiple)\n    } else {\n      xpostag.push(chunks[j]);\n    }\n  }\n\n  // return our extracted data\n  return {\n    lemma: lemma,\n    xpostag: xpostag.join(';') || undefined,\n    head: head,\n    deprel: deprel,\n    deps: deps,\n    misc: misc.join(';') || undefined\n  };\n}\n\n/**\n * parse an array of strings representing a CG3 analysis ... recall that in CG3,\n *   subTokens have an increasingly hanging indent from their superToken\n *\n * @param {Token} token token to attach the analyses to\n * @param {Array} lines [[String]]\n * @return {undefined}\n */\nfunction cg3StringParseAnalysis(token, lines) {\n\n  if (lines.length === 2) {\n\n    // no subTokens\n    var tags = cg3StringGetTags(lines[1]); // extract tags\n    tags.form = cg3StringGetForm(lines[0]); // extract the form\n    token.pushAnalysis(new Analysis(token, tags)); // save to token\n  } else {\n\n    // has subTokens\n    var analysis = new Analysis(token, {\n      form: cg3StringGetForm(lines[0]) // superToken only save form\n    });\n\n    // for each subToken\n    for (var i = 1; i < lines.length; i++) {\n      var _tags = cg3StringGetTags(lines[i]); // extract tags\n      var subToken = new Token(token.sentence, _tags); // make new subToken\n      analysis.pushSubToken(subToken); // attach to this analysis\n    }\n    token.pushAnalysis(analysis); // save to token\n  }\n}\n\n// define all the CG3-parsing regex here\nvar cg3Regex = {\n  form: /^\"<((.|\\\\\")*)>\"/,\n  lemma: /[\"\\]](.*)[\"\\]](\\s|$)/,\n  head: /->(.*)$/,\n  dependency: /^#(.+)->(.*)/,\n  deprel: /^@(.*)/,\n  misc: /.+:.*/\n};\n\n/**\n * this class contains all the information associated with a token, including\n *   a possible superToken, an array of possible analyses, an index to the\n *   current analysis, and a Boolean representing whether it is an \"empty\" token\n */\n\nvar Token = function () {\n  function Token(sent, params) {\n    _classCallCheck(this, Token);\n\n    // require sentence param\n    if (!sent) throw new NotatrixError('missing required arg: Sentence');\n\n    // pointer to parent\n    this.sentence = sent;\n\n    // internal stuff\n    this.superToken = null;\n    this.analyses = []; // array of analyses\n    this._current = null; // index of current analysis in array\n    this._isEmpty = false; // used for CoNLL-U \"empty\" tokens\n\n    // try parsing an analysis from params\n    if (params) this.analysis = new Analysis(this, params);\n  }\n\n  /**\n   *\n   * @return {Number} total number of analyses in this token\n   */\n\n\n  _createClass(Token, [{\n    key: 'forEach',\n\n\n    /**\n     * loop through every analysis in the sentence and apply a callback\n     *\n     * @param {Function} callback function to be applied to every analysis\n     * @return {Token}\n     */\n    value: function forEach(callback) {\n\n      for (var i = 0; i < this.length; i++) {\n        callback(this.analyses[i], i);\n      }\n\n      // chaining\n      return this;\n    }\n\n    // keeping track of ambiguous analyses\n\n    /**\n     * decrement the _current counter by one (set \"previous\" analysis as current)\n     *\n     * @return {Token}\n     */\n\n  }, {\n    key: 'prev',\n    value: function prev() {\n\n      // if no analyses set whatsoever\n      if (this._current === null) return null;\n\n      // if we're not already at the first one\n      if (this._current > 0) this._current--;\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * increment the _current counter by one (set \"next\" analysis as current)\n     *\n     * @return {Token}\n     */\n\n  }, {\n    key: 'next',\n    value: function next() {\n\n      // if no analyses set whatsoever\n      if (this._current === null) return null;\n\n      // if we're not already at the last one\n      if (this._current < this.length - 1) this._current++;\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * return the _current index\n     *\n     * @return {Number}\n     */\n\n  }, {\n    key: 'insertAnalysisAt',\n\n\n    // manipulate analyses array\n\n    /**\n     * insert an analysis BEFORE the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length), then it will be adjusted\n     *   to fit the bounds. this means that you can call this with `index=-Infinity`\n     *   to push to the front of the analyses array or with `index=Infinity` to push\n     *   to the end\n     *\n     * @param {Number} index\n     * @param {Analysis} analysis\n     * @return {Token}\n     *\n     * @throws {NotatrixError} if given invalid index or analysis\n     */\n    value: function insertAnalysisAt(index, analysis) {\n\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to insert subToken: unable to cast index to int');\n\n      if (!(analysis instanceof Analysis)) throw new NotatrixError('unable to insert analysis: not instance of Analysis');\n\n      // if we had no analyses, make this the first\n      if (this.current === null) this._current = 0;\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.length ? this.length : parseInt(index);\n\n      // set the parent pointer on the analysis\n      analysis.token = this;\n\n      // array insertion\n      this.analyses = this.analyses.slice(0, index).concat(analysis).concat(this.analyses.slice(index));\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * remove an analysis at the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length - 1), then it will be\n     *   adjusted to fit the bounds. this means that you can call this with\n     *   `index=-Infinity` to remove the first element of the analyses array or\n     *   with `index=Infinity` to remove the last\n     *\n     * @param {Number} index\n     * @return {(null|Analysis)}\n     *\n     * @throws {NotatrixError} if given invalid index\n     */\n\n  }, {\n    key: 'removeAnalysisAt',\n    value: function removeAnalysisAt(index) {\n\n      // can't remove if we have an empty array\n      if (!this.length) return null;\n\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to remove subToken: unable to cast index to int');\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.length - 1 ? this.length - 1 : parseInt(index);\n\n      // go to previous analysis if we just deleted our current one or before it\n      if (this.current >= index) this.prev();\n\n      // if we now have an empty array, update _current\n      if (this.length === 1) this._current = null;\n\n      // array splicing, return spliced element\n      return this.analyses.splice(index, 1)[0];\n    }\n\n    /**\n     * move an analysis from sourceIndex to targetIndex\n     *\n     * NOTE: if either index is out of bounds (<0 or >length - 1), then it will\n     *   be adjusted to fit the bounds. this means that you can call this with\n     *   `sourceIndex=-Infinity` to select the first element of the analyses array\n     *   or with `sourceIndex=Infinity` to select the last\n     *\n     * @param {Number} sourceIndex\n     * @param {Number} targetIndex\n     * @return {Token}\n     *\n     * @throws {NotatrixError} if given invalid sourceIndex or targetIndex\n     */\n\n  }, {\n    key: 'moveAnalysisAt',\n    value: function moveAnalysisAt(sourceIndex, targetIndex) {\n\n      sourceIndex = parseFloat(sourceIndex);\n      targetIndex = parseFloat(targetIndex);\n      if (isNaN(sourceIndex) || isNaN(targetIndex)) throw new NotatrixError('unable to move analysis: unable to cast indices to ints');\n\n      // bounds checking\n      sourceIndex = sourceIndex < 0 ? 0 : sourceIndex > this.length - 1 ? this.length - 1 : parseInt(sourceIndex);\n      targetIndex = targetIndex < 0 ? 0 : targetIndex > this.length - 1 ? this.length - 1 : parseInt(targetIndex);\n\n      if (sourceIndex === targetIndex) {\n        // do nothing\n      } else {\n\n        // array splice and insert\n        var analysis = this.analyses.splice(sourceIndex, 1);\n        this.analyses = this.analyses.slice(0, targetIndex).concat(analysis).concat(this.analyses.slice(targetIndex));\n      }\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * push an analysis to the end of the analyses array ... sugar for\n     *   Token::insertAnalysisAt(Infinity, analysis)\n     *\n     * @param {Analysis} analysis\n     * @return {Token}\n     */\n\n  }, {\n    key: 'pushAnalysis',\n    value: function pushAnalysis(analysis) {\n      return this.insertAnalysisAt(Infinity, analysis);\n    }\n\n    /**\n     * pop an analysis from the end of the analyses array ... sugar for\n     *   Token::insertRemoveAt(Infinity)\n     *\n     * @return {(null|Analysis)}\n     */\n\n  }, {\n    key: 'popAnalysis',\n    value: function popAnalysis() {\n      return this.removeAnalysisAt(Infinity);\n    }\n\n    // token combining, merging, splitting\n\n  }, {\n    key: 'combineWith',\n    value: function combineWith(token) {}\n  }, {\n    key: 'mergeWith',\n    value: function mergeWith(token) {\n      if (!(token instanceof Token)) throw new NotatrixError('unable to merge: not instance of Token');\n\n      if (this === token) throw new NotatrixError('unable to merge: can\\'t merge with self');\n\n      if (this.isSuperToken || token.isSuperToken) throw new NotatrixError('unable to merge: can\\'t merge superTokens');\n\n      if (this.superToken !== token.superToken) throw new NotatrixError('unable to merge: can\\'t merge tokens with different superTokens');\n\n      var dist = Math.abs(this.analysis.clump - token.analysis.clump);\n      if (dist !== 1) throw new NotatrixError('unable to merge: tokens must be adjacent');\n\n      if (this.analysis === null || token.analysis === null) throw new NotatrixError('unable to merge: tokens must have at least one analysis');\n\n      // combine the form and lemma fields\n      this.analysis.form = (this.analysis.form || '') + (token.analysis.form || '') || null;\n      this.analysis.lemma = (this.analysis.lemma || '') + (token.analysis.lemma || '') || null;\n\n      // take one of these fields\n      this.upostag = this.upostag || token.upostag || null;\n      this.xpostag = this.xpostag || token.xpostag || null;\n      this.feats = this.feats || token.feats || null;\n      this.misc = this.misc || token.misc || null;\n\n      // remove the token\n      if (token.isSubToken) {\n\n        var indices = this.sentence.getIndices(token);\n        this.superToken.removeSubTokenAt(indices.sub);\n      } else {\n\n        var _indices = this.sentence.getIndices(token);\n        this.sentence.removeTokenAt(_indices.super);\n      }\n\n      this.sentence.index();\n      return this; // chaining\n    }\n  }, {\n    key: 'split',\n    value: function split() {}\n\n    // internal format\n\n    /**\n     * get the current analysis for the token or null if none exist\n     *\n     * @return {(null|Analysis)}\n     */\n\n  }, {\n    key: 'index',\n\n\n    // external format stuff\n\n    /**\n     * iterate over this token and its subTokens (if we have any) for the current\n     *   analysis, using the `id` and `empty` params to set indices\n     *\n     * @param {Number} id \"overall\" index\n     * @param {Number} empty\n     * @return {Array} [Number, Number]\n     *\n     * @throws {NotatrixError} if given invalid id or empty\n     */\n    value: function index(id, empty, num, clump) {\n      var _this = this;\n\n      id = parseInt(id);\n      empty = parseInt(empty);\n      num = parseInt(num);\n      clump = parseInt(clump);\n\n      if (isNaN(id) || isNaN(empty) || isNaN(num) || isNaN(clump)) throw new NotatrixError('can\\'t index tokens using non-integers, make sure to call Sentence.index()');\n\n      // if no analysis, nothing to do\n      if (this.analysis === null) return [id, empty, num, clump];\n\n      // iterate over analyses\n      this.forEach(function (analysis) {\n\n        // only set the \"id\" and \"empty\" indices on the current analysis\n        if (analysis.isCurrent) {\n          if (_this.isSuperToken) {\n\n            // save the absolute index\n            _this.analysis.num = num;\n            _this.analysis.clump = null;\n            num++;\n\n            // index subTokens\n            _.each(_this.analysis.subTokens, function (subToken) {\n              if (subToken.isEmpty) {\n                empty++; // incr empty counter\n                subToken.analysis.id = id + '.' + empty; // dot syntax\n              } else {\n                id++; // incr regular counter\n                subToken.analysis.id = '' + id; // vanilla syntax\n                empty = 0; // reset empty counter\n              }\n\n              // save the absolute index\n              subToken.forEach(function (analysis) {\n                analysis.num = num;\n                num++;\n                analysis.clump = clump;\n                clump++;\n              });\n            });\n\n            // set special superToken index scheme\n            var firstSubAnalysis = _this.subTokens[0].analysis;\n            var lastSubAnalysis = _this.subTokens[_this.analysis.length - 1].analysis;\n            _this.analysis.id = firstSubAnalysis.id + '-' + lastSubAnalysis.id;\n          } else {\n\n            // save the absolute index\n            _this.analysis.num = num;\n            num++;\n            _this.analysis.clump = clump;\n            clump++;\n\n            if (_this.isEmpty) {\n              empty++; // incr empty counter\n              _this.analysis.id = id + '.' + empty; // dot syntax\n            } else {\n              id++; // incr regular counter\n              _this.analysis.id = '' + id; // vanilla syntax\n              empty = 0; // reset empty counter\n            }\n          }\n        } else {\n\n          // save the absolute index\n          _this.analysis.num = num;\n          num++;\n\n          // non-current analyses get \"id\" and \"empty\" indices set to null\n          analysis.id = null;\n          _.each(analysis.subTokens, function (subToken) {\n            subToken.analysis.id = null;\n\n            subToken.forEach(function (analysis) {\n\n              // save the absolute index\n              _this.analysis.num = num;\n              num++;\n            });\n          });\n        }\n      });\n\n      // return updated indices\n      return [id, empty, num, clump];\n    }\n\n    /**\n     * get a serial version of the internal token representation\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n\n      return this.analyses.length;\n    }\n  }, {\n    key: 'current',\n    get: function get() {\n\n      return this._current;\n    }\n\n    /**\n     * set the _current index to the given index if possible\n     *\n     * @param {Number} current\n     * @return {Number}\n     */\n    ,\n    set: function set(current) {\n\n      // force cast to int\n      current = parseInt(current);\n      if (isNaN(current)) return this.current;\n\n      // bounds checking\n      if (current < 0) return this.current;\n      if (current > this.length - 1) return this.current;\n\n      // set and return it\n      this._current = current;\n      return this.current;\n    }\n  }, {\n    key: 'analysis',\n    get: function get() {\n\n      if (this.current === null) return null;\n      return this.analyses[this.current];\n    }\n\n    /**\n     * set the current analysis for the token\n     *\n     * NOTE: if there is already an analysis, overwrite\n     *\n     * @param {Analysis} analysis\n     * @return {Token}\n     *\n     * @throws {NotatrixError} if given invalid analysis\n     */\n    ,\n    set: function set(analysis) {\n\n      if (!(analysis instanceof Analysis)) throw new NotatrixError('unable to set analysis: not instance of Analysis');\n\n      if (this.analysis === null) {\n        // push to front if we have no analyses\n        this.insertAnalysisAt(0, analysis);\n      } else {\n        // otherwise overwrite\n        analysis.token = this;\n        this.analyses[this.current] = analysis;\n      }\n\n      return this;\n    }\n\n    /**\n     * if we have a current analysis, return its subTokens\n     *\n     * @return {(null|Array)}\n     */\n\n  }, {\n    key: 'subTokens',\n    get: function get() {\n\n      if (this.analysis === null) return null;\n      return this.analysis.subTokens;\n    }\n  }, {\n    key: 'nx',\n    get: function get() {\n\n      // serialize analyses\n      var analyses = [];\n      this.forEach(function (analysis) {\n        analyses.push(analysis.nx);\n      });\n\n      // serialize other data\n      return {\n        current: this.current,\n        analyses: analyses\n      };\n    }\n\n    /**\n     * get a plain-text formatted string of the current analysis text\n     *\n     * @return {String}\n     *\n     * @throws {NotatrixError} if no analysis\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n\n      if (this.analysis === null) throw new NotatrixError('no analysis to get text for');\n\n      return this.analysis.text || '';\n    }\n\n    /**\n     * get a CoNLL-U formatted string representing the current analysis\n     *\n     * @return {String}\n     *\n     * @throws {NotatrixError} if no analysis\n     * @throws {InvalidCoNLLUError} if ambiguous\n     */\n\n  }, {\n    key: 'conllu',\n    get: function get() {\n\n      if (this.analysis === null) throw new NotatrixError('no analysis to get CoNLL-U for');\n\n      if (this.isAmbiguous) throw new InvalidCoNLLUError('Token is ambiguous, can\\'t be converted to CoNNL-U');\n\n      return this.analysis.conllu;\n    }\n\n    /**\n     * parse a CoNLL-U formatted string and save its contents to the current analysis\n     *\n     * @param {String} serial\n     * @return {undefined}\n     */\n    ,\n    set: function set(serial) {\n      // split serial string on whitespace\n      var fields = split(serial);\n\n      // check if serial index indicates an \"empty\" token\n      this._isEmpty = /\\./.test(fields[0]);\n\n      // generate an analysis from the fields\n      this.analysis = new Analysis(this, {\n        form: fields[1],\n        lemma: fields[2],\n        upostag: fields[3],\n        xpostag: fields[4],\n        feats: fields[5],\n        head: fields[6],\n        deprel: fields[7],\n        deps: fields[8],\n        misc: fields[9]\n      });\n    }\n\n    /**\n     * static method allowing us to construct a new Token directly from a\n     *   CoNLL-U string and bind it to a sentence\n     *\n     * @param {Sentence} sent\n     * @param {String} serial\n     * @return {Token}\n     */\n\n  }, {\n    key: 'cg3',\n\n\n    /**\n     * get a CG3 formatted string representing the current analysis\n     *\n     * @return {String}\n     *\n     * @throws {NotatrixError} if no analysis\n     */\n    get: function get() {\n      if (this.analysis === null) throw new NotatrixError('no analysis to get CG3 for');\n\n      // the form goes on its own line, with each analysis below\n      return ['\"<' + this.analysis.form + '>\"'].concat(this.analyses.map(function (analysis) {\n        return analysis.cg3;\n      })).join('\\n');\n    }\n\n    /**\n     * parse a CG3 formatted string and save its contents to the current analysis\n     *\n     * @param {Array} tokenLines generated in Sentence::cg3 [set] by splitting\n     *   a serial string on newlines\n     * @return {undefined}\n     */\n    ,\n    set: function set(tokenLines) {\n      // again, we have complicated parsing here ... first make sure we get an\n      //   array of the important information (minimally the form on the first line)\n      var analysis = [tokenLines[0]];\n\n      // iterate over the strings\n      for (var i = 1; i < tokenLines.length; i++) {\n\n        // ignore leading semicolons (TODO: determine what these are)\n        var line = tokenLines[i].replace(/^;/, '');\n\n        // determine line indent\n        var indent = getIndent(line);\n\n        // if we're back at indent=1 and we already have stuff in our analysis\n        //   buffer, parse it as an analysis\n        if (indent === 1 && i > 1) {\n          // parse as analysis\n          cg3StringParseAnalysis(this, analysis);\n          // reset buffer\n          analysis = [tokenLines[0]];\n        }\n\n        // add to buffer\n        analysis.push(line);\n      }\n\n      // parse and clear buffer\n      cg3StringParseAnalysis(this, analysis);\n    }\n\n    /**\n     * static method allowing us to construct a new Token directly from a\n     *   CG3 string\n     *\n     * @param {Sentence} sent\n     * @param {Array} tokenLines\n     * @return {Token}\n     */\n\n  }, {\n    key: 'params',\n\n\n    /**\n     * get the token parameters for the current analysis\n     *\n     * @return {Object}\n     *\n     * @throws {NotatrixError} if no analysis\n     */\n    get: function get() {\n      if (this.analysis === null) throw new NotatrixError('no analysis to get params for');\n\n      return this.analysis.params;\n    }\n\n    /**\n     * set a set of parameters as the current analysis\n     *\n     * @param {Object} params\n     * @return {Object}\n     */\n    ,\n    set: function set(params) {\n      this.analysis = new Analysis(this, params);\n      return this.params;\n    }\n\n    /**\n     * static method allowing us to construct a new Token directly from a set\n     *   of parameters\n     *\n     * @param {Sentence} sent\n     * @param {Object} params\n     * @return {Token}\n     */\n\n  }, {\n    key: 'eles',\n\n\n    /**\n     * get an array of elements for exporting to external visualization libraries\n     *   for all the analyses of this token\n     *\n     * @return {Array}\n     */\n    get: function get() {\n      var eles = [];\n      this.forEach(function (analysis) {\n        eles = eles.concat(analysis.eles);\n      });\n\n      return eles;\n    }\n\n    // bool stuff\n\n    /**\n     * returns true iff this token is a subToken of some other token\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSubToken',\n    get: function get() {\n      return this.superToken !== null;\n    }\n\n    /**\n     * returns true iff this token has subTokens\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSuperToken',\n    get: function get() {\n      return this.analysis ? this.analysis.isSuperToken : null;\n    }\n\n    /**\n     * returns true iff this token or its superToken is an \"empty\" token\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.isSubToken ? this.superToken.token.isEmpty : this._isEmpty;\n    }\n\n    /**\n     * return true iff this token has more than one analysis\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAmbiguous',\n    get: function get() {\n      return this.length > 1;\n    }\n  }], [{\n    key: 'fromConllu',\n    value: function fromConllu(sent, serial) {\n      var token = new Token(sent);\n      token.conllu = serial;\n      return token;\n    }\n  }, {\n    key: 'fromCG3',\n    value: function fromCG3(sent, tokenLines) {\n      var token = new Token(sent);\n      token.cg3 = tokenLines;\n      return token;\n    }\n  }, {\n    key: 'fromParams',\n    value: function fromParams(sent, params) {\n      var token = new Token(sent);\n      token.params = params;\n      return token;\n    }\n  }]);\n\n  return Token;\n}();\n\n// expose to application\n\n\nmodule.exports = Token;\n\n},{\"./analysis\":2,\"./errors\":3,\"underscore\":1}]},{},[4])(4)\n});\n"]}