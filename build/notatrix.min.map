{"version":3,"sources":["notatrix.min.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","global","root","self","this","previousUnderscore","_","ArrayProto","Array","prototype","ObjProto","Object","SymbolProto","Symbol","push","slice","toString","hasOwnProperty","nativeIsArray","isArray","nativeKeys","keys","nativeCreate","create","Ctor","obj","_wrapped","nodeType","VERSION","builtinIteratee","optimizeCb","func","context","argCount","value","index","collection","accumulator","apply","arguments","cb","iteratee","identity","isFunction","isObject","matcher","property","Infinity","restArguments","startIndex","Math","max","rest","args","baseCreate","result","shallowProperty","key","has","path","deepGet","MAX_ARRAY_INDEX","pow","getLength","isArrayLike","each","forEach","map","collect","results","currentKey","createReduce","dir","memo","initial","reducer","reduce","foldl","inject","reduceRight","foldr","find","detect","predicate","findIndex","findKey","filter","select","list","reject","negate","every","all","some","any","contains","includes","include","item","fromIndex","guard","values","indexOf","invoke","contextPath","method","pluck","where","attrs","findWhere","computed","lastComputed","v","min","shuffle","sample","random","clone","last","rand","temp","sortBy","criteria","sort","left","right","b","group","behavior","partition","groupBy","indexBy","countBy","reStrSymbol","toArray","isString","match","size","pass","first","head","take","array","tail","drop","compact","Boolean","flatten","input","shallow","strict","output","idx","isArguments","j","len","without","otherArrays","difference","uniq","unique","isSorted","isBoolean","seen","union","arrays","intersection","argsLength","unzip","zip","object","createPredicateIndexFinder","findLastIndex","sortedIndex","low","high","mid","floor","createIndexFinder","predicateFind","isNaN","lastIndexOf","range","start","stop","step","ceil","chunk","count","executeBound","sourceFunc","boundFunc","callingContext","bind","TypeError","bound","callArgs","concat","partial","boundArgs","placeholder","position","bindAll","memoize","hasher","cache","address","delay","wait","setTimeout","defer","throttle","options","timeout","previous","later","leading","now","throttled","remaining","clearTimeout","trailing","cancel","debounce","immediate","debounced","callNow","wrap","wrapper","compose","after","times","before","once","hasEnumBug","propertyIsEnumerable","nonEnumerableProps","collectNonEnumProps","nonEnumIdx","constructor","proto","prop","allKeys","mapObject","pairs","invert","functions","methods","names","createAssigner","keysFunc","defaults","source","l","extend","extendOwn","assign","eq","deepEq","keyInObj","pick","omit","String","props","tap","interceptor","isMatch","aStack","bStack","type","className","valueOf","areArrays","aCtor","bCtor","pop","isEqual","isEmpty","isElement","name","nodelist","document","childNodes","Int8Array","isFinite","isSymbol","parseFloat","isNumber","isNull","isUndefined","noConflict","constant","noop","propertyOf","matches","accum","Date","getTime","escapeMap","&","<",">","\"","'","`","unescapeMap","createEscaper","escaper","join","testRegexp","RegExp","replaceRegexp","string","test","replace","escape","unescape","fallback","idCounter","uniqueId","prefix","id","templateSettings","evaluate","interpolate","noMatch","escapes","\\","\r","\n"," "," ","escapeRegExp","escapeChar","template","text","settings","oldSettings","render","offset","variable","Function","data","argument","chain","instance","_chain","chainResult","mixin","toJSON","define","amd","window","2","_typeof","iterator","_createClass","defineProperties","target","descriptor","enumerable","configurable","writable","defineProperty","Constructor","protoProps","staticProps","NotatrixError","sanitize","str","parseEnhancedString","heads","split","token","deprel","evaluatePunctPos","ana","puncts","sentence","help","upostag","xpostag","cg3FormatOutput","analysis","tabs","indent","fill","tags","misc","dependency","showEmptyDependencies","lemma","fields","Analysis","_Object","params","_classCallCheck","_this","ReferenceError","_possibleConstructorReturn","__proto__","getPrototypeOf","initializing","_heads","_deps","undefined","subTokens","subClass","superClass","setPrototypeOf","_inherits","isSuperToken","isSubToken","parseInt","superToken","splice","sourceIndex","targetIndex","subToken","insertSubTokenAt","removeSubTokenAt","callback","changeHead","_this2","removing","eachHead","eachDep","_this3","done","_deprel","dep","changeDep","deps","_this4","_this5","get","_this6","field","nx","form","_this7","_form","_lemma","set","_upostag","_xpostag","_feats","feats","_this8","showEnhanced","getById","_this9","_this10","_this11","_misc","Proxy","receiver","./errors","underscore","3","_Error","_ref","_len","_key","InvalidCG3Error","_NotatrixError","_ref2","_len2","_key2","InvalidCoNLLUError","_NotatrixError2","_ref3","_len3","_key3","TransformationError","_NotatrixError3","_ref4","_len4","_key4","4","Sentence","Token","./analysis","./sentence","./token","5","_slicedToArray","arr","_arr","_n","_d","_e","_s","_i","next","err","sliceIterator","regex","comment","commentContent","empty","cg3TokenStart","cg3TokenContent","paramsList","prettyOutput","comments","tokens","tok","insertTokenAt","removeTokenAt","_token$index","_token$index2","acc","JSON","stringify","conllu","lines","trim","fromConllu","k","subTokenIndices","pushSubToken","pushToken","attach","cg3","tokenLines","isToken","isContent","fromCG3","isAmbiguous","console","warn","fromParams","valid","serial","sent","6","getIndent","line","chars","cg3StringGetForm","cg3Regex","cg3StringGetTags","chunks","cg3StringParseAnalysis","pushAnalysis","_tags","analyses","_current","_isEmpty","current","prev","insertAnalysisAt","removeAnalysisAt","firstSubAnalysis","lastSubAnalysis"],"mappings":"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","file":"notatrix.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n(function (global){\n//     Underscore.js 1.9.1\n//     http://underscorejs.org\n//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n            typeof global == 'object' && global.global === global && global ||\n            this ||\n            {};\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if (typeof exports != 'undefined' && !exports.nodeType) {\n    if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.9.1';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-argument case is omitted because we’re not using it.\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  var builtinIteratee;\n\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);\n    return _.property(value);\n  };\n\n  // External wrapper for our callback generator. Users may customize\n  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n  // This abstraction hides the internal-only argCount argument.\n  _.iteratee = builtinIteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // Some functions take a variable number of arguments, or a few expected\n  // arguments at the beginning and then a variable number of values to operate\n  // on. This helper accumulates all remaining arguments past the function’s\n  // argument length (or an explicit `startIndex`), into an array that becomes\n  // the last argument. Similar to ES6’s \"rest parameter\".\n  var restArguments = function(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var shallowProperty = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  var has = function(obj, path) {\n    return obj != null && hasOwnProperty.call(obj, path);\n  }\n\n  var deepGet = function(obj, path) {\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      if (obj == null) return void 0;\n      obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object.\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = shallowProperty('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  var createReduce = function(dir) {\n    // Wrap code that reassigns argument variables in a separate function than\n    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n    var reducer = function(obj, iteratee, memo, initial) {\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      if (!initial) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    };\n\n    return function(obj, iteratee, memo, context) {\n      var initial = arguments.length >= 3;\n      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n    };\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;\n    var key = keyFinder(obj, predicate, context);\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = restArguments(function(obj, path, args) {\n    var contextPath, func;\n    if (_.isFunction(path)) {\n      func = path;\n    } else if (_.isArray(path)) {\n      contextPath = path.slice(0, -1);\n      path = path[path.length - 1];\n    }\n    return _.map(obj, function(context) {\n      var method = func;\n      if (!method) {\n        if (contextPath && contextPath.length) {\n          context = deepGet(context, contextPath);\n        }\n        if (context == null) return void 0;\n        method = context[path];\n      }\n      return method == null ? method : method.apply(context, args);\n    });\n  });\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection.\n  _.shuffle = function(obj) {\n    return _.sample(obj, Infinity);\n  };\n\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    var index = 0;\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, key, list) {\n      return {\n        value: value,\n        index: index++,\n        criteria: iteratee(value, key, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior, partition) {\n    return function(obj, iteratee, context) {\n      var result = partition ? [[], []] : {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (_.isString(obj)) {\n      // Keep surrogate pair characters together\n      return obj.match(reStrSymbol);\n    }\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = group(function(result, value, pass) {\n    result[pass ? 0 : 1].push(value);\n  }, true);\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null || array.length < 1) return n == null ? void 0 : [];\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null || array.length < 1) return n == null ? void 0 : [];\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, Boolean);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, output) {\n    output = output || [];\n    var idx = output.length;\n    for (var i = 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        // Flatten current level of array or arguments object.\n        if (shallow) {\n          var j = 0, len = value.length;\n          while (j < len) output[idx++] = value[j++];\n        } else {\n          flatten(value, shallow, strict, output);\n          idx = output.length;\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = restArguments(function(array, otherArrays) {\n    return _.difference(array, otherArrays);\n  });\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // The faster algorithm will not work with an iteratee if the iteratee\n  // is not a one-to-one function, so providing an iteratee will disable\n  // the faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted && !iteratee) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = restArguments(function(arrays) {\n    return _.uniq(flatten(arrays, true, true));\n  });\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      var j;\n      for (j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = restArguments(function(array, rest) {\n    rest = flatten(rest, true, true);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  });\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices.\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = restArguments(_.unzip);\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values. Passing by pairs is the reverse of _.pairs.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions.\n  var createPredicateIndexFinder = function(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  };\n\n  // Returns the first index on an array-like that passes a predicate test.\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions.\n  var createIndexFinder = function(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    if (!step) {\n      step = stop < start ? -1 : 1;\n    }\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Chunk a single array into multiple arrays, each containing `count` or fewer\n  // items.\n  _.chunk = function(array, count) {\n    if (count == null || count < 1) return [];\n    var result = [];\n    var i = 0, length = array.length;\n    while (i < length) {\n      result.push(slice.call(array, i, i += count));\n    }\n    return result;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments.\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = restArguments(function(func, context, args) {\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var bound = restArguments(function(callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder by default, allowing any combination of arguments to be\n  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\n  _.partial = restArguments(function(func, boundArgs) {\n    var placeholder = _.partial.placeholder;\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\n  _.partial.placeholder = _;\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = restArguments(function(obj, keys) {\n    keys = flatten(keys, false, false);\n    var index = keys.length;\n    if (index < 1) throw new Error('bindAll must be passed function names');\n    while (index--) {\n      var key = keys[index];\n      obj[key] = _.bind(obj[key], obj);\n    }\n  });\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = restArguments(function(func, wait, args) {\n    return setTimeout(function() {\n      return func.apply(null, args);\n    }, wait);\n  });\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n\n    var later = function(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArguments(function(args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  _.restArguments = restArguments;\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`.\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object.\n  // In contrast to _.map it returns an object.\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = _.keys(obj),\n        length = keys.length,\n        results = {};\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  // The opposite of _.object.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`.\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, defaults) {\n    return function(obj) {\n      var length = arguments.length;\n      if (defaults) obj = Object(obj);\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!defaults || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s).\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test.\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Internal pick helper function to determine if `obj` has key `key`.\n  var keyInObj = function(value, key, obj) {\n    return key in obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = restArguments(function(obj, keys) {\n    var result = {}, iteratee = keys[0];\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n      keys = _.allKeys(obj);\n    } else {\n      iteratee = keyInObj;\n      keys = flatten(keys, false, false);\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  });\n\n  // Return a copy of the object without the blacklisted properties.\n  _.omit = restArguments(function(obj, keys) {\n    var iteratee = keys[0], context;\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n      if (keys.length > 1) context = keys[1];\n    } else {\n      keys = _.map(flatten(keys, false, false), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  });\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq, deepEq;\n  eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) return false;\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) return b !== b;\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\n    return deepEq(a, b, aStack, bStack);\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  deepEq = function(a, b, aStack, bStack) {\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN.\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n      case '[object Symbol]':\n        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\n  var nodelist = root.document && root.document.childNodes;\n  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && isNaN(obj);\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, path) {\n    if (!_.isArray(path)) {\n      return has(obj, path);\n    }\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      var key = path[i];\n      if (obj == null || !hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n      obj = obj[key];\n    }\n    return !!length;\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  // Creates a function that, when passed an object, will traverse that object’s\n  // properties down the given `path`, specified as an array of keys or indexes.\n  _.property = function(path) {\n    if (!_.isArray(path)) {\n      return shallowProperty(path);\n    }\n    return function(obj) {\n      return deepGet(obj, path);\n    };\n  };\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    if (obj == null) {\n      return function(){};\n    }\n    return function(path) {\n      return !_.isArray(path) ? obj[path] : deepGet(obj, path);\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // Traverses the children of `obj` along `path`. If a child is a function, it\n  // is invoked with its parent as context. Returns the value of the final\n  // child, or `fallback` if any child is undefined.\n  _.result = function(obj, path, fallback) {\n    if (!_.isArray(path)) path = [path];\n    var length = path.length;\n    if (!length) {\n      return _.isFunction(fallback) ? fallback.call(obj) : fallback;\n    }\n    for (var i = 0; i < length; i++) {\n      var prop = obj == null ? void 0 : obj[path[i]];\n      if (prop === void 0) {\n        prop = fallback;\n        i = length; // Ensure we don't continue iterating.\n      }\n      obj = _.isFunction(prop) ? prop.call(obj) : prop;\n    }\n    return obj;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offset.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    var render;\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var chainResult = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return chainResult(this, func.apply(_, args));\n      };\n    });\n    return _;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return chainResult(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return chainResult(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return String(this._wrapped);\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define == 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}());\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _ = require('underscore');\n\nvar NotatrixError = require('./errors').NotatrixError;\n\n/**\n * strip whitespace from a string\n *\n * @param {String} str\n * @return {String}\n */\nfunction sanitize(str) {\n  return (str || '').replace(/\\s/g, '');\n}\n\n/**\n * take a string possibly given in enhanced notation and extract the head\n *   and deprel\n *\n * e.g. `2:ccomp|3:nsubj` => `[\n *   { token: 2, deprel: 'ccomp' },\n *   { token: 3, deprel: 'nsubj' } ]`\n *\n * @param {String} str\n * @return {Array} [[Object]]\n */\nfunction parseEnhancedString(str) {\n\n  // strip whitespace in input\n  str = sanitize(str);\n\n  // keep our heads here\n  var heads = [];\n\n  // iterate over \"|\"-delimited chunks\n  _.each(str.split('|'), function (head) {\n    head = head.split(':');\n\n    // ignore it if we don't parse a head\n    if (head[0]) heads.push({\n      token: head[0],\n      deprel: head[1]\n    });\n  });\n  return heads;\n}\n\n/**\n * automatically add PUNCT pos tags to strings that consist of only punctuation\n *\n * NOTE: only has an effect if sentence-level options help.upostag|help.xpostag\n *   are set to true (default: true)\n *\n * @param {Analysis} ana the analysis to evaluate for\n * @param {String} string\n * @return {undefined}\n */\nfunction evaluatePunctPos(ana, string) {\n  if (puncts.test(string)) {\n    if (ana.sentence.options.help.upostag && !ana.upostag) ana.upostag = 'PUNCT';\n\n    if (ana.sentence.options.help.xpostag && !ana.xpostag) ana.xpostag = 'PUNCT';\n  }\n}\n\n/**\n * helper function for Analysis::cg3 [get] ... actually does the work of\n *   deciding how we want to display the information contained in an analysis\n *\n * @param {Analysis} ana\n * @param {Number} tabs current indent level\n * @return {String}\n */\nfunction cg3FormatOutput(analysis, tabs) {\n\n  var indent = new Array(tabs).fill('\\t').join('');\n  var tags = analysis.xpostag ? ' ' + analysis.xpostag.replace(/;/g, ' ') : '';\n  var misc = analysis.misc ? ' ' + analysis.misc.replace(/;/g, ' ') : '';\n  var deprel = analysis.deprel ? ' @' + analysis.deprel : '';\n  var id = analysis.id ? ' #' + analysis.id + '->' : '';\n  var head = id && analysis.head ? '' + analysis.head : '';\n  var dependency = head || id && analysis.sentence.options.showEmptyDependencies ? '' + id + head : '';\n\n  return indent + '\"' + analysis.lemma + '\"' + tags + misc + deprel + dependency;\n}\n\n// placeholder for CoNLL-U export in `undefined` fields\nvar fallback = '_';\n// setteable fields\nvar fields = [\n// NB: 'id' is not kept here\n'form', 'lemma', 'upostag', 'xpostag', 'feats', 'head', 'deprel', 'deps', 'misc'];\n// supported punctuation characters\nvar puncts = /[.,!?]/;\n\n/**\n * this class contains all the information associated with an analysis, including\n *   a value for each of form, lemma, upostag, xpostag, feats, head, deprel,\n *   deps, & misc ... also keeps an array of subTokens and an index\n */\n\nvar Analysis = function (_Object) {\n  _inherits(Analysis, _Object);\n\n  function Analysis(token, params) {\n    _classCallCheck(this, Analysis);\n\n    // require token param\n    var _this = _possibleConstructorReturn(this, (Analysis.__proto__ || Object.getPrototypeOf(Analysis)).call(this));\n\n    if (!token) throw new NotatrixError('missing required arg: Token');\n\n    // used to make sure we only add the head/deps strings on first pass, since\n    //   we'll eventually call attach() whenever we're constructing like this\n    _this.initializing = true;\n\n    // pointers to parents\n    _this.token = token;\n    _this.sentence = token.sentence;\n\n    // internal arrays of Analyses\n    _this._heads = [];\n    _this._deps = [];\n\n    // iterate over passed params\n    _.each(params, function (value, key) {\n      if (value === undefined || fields.indexOf(key) === -1) {\n        // delete invalid parameters\n        delete params[key];\n      } else {\n        // save valid ones (using our setters defined below)\n        _this[key] = value;\n      }\n    });\n\n    // save updated params (mostly for debugging purposes)\n    _this.params = params || {};\n\n    // internal index (see Sentence::index and Token::index), don't change this!\n    _this.id = null;\n\n    // array of Tokens\n    _this.subTokens = [];\n\n    // safe to unset this now\n    _this.initializing = false;\n\n    return _this;\n  }\n\n  /**\n   * @return {Number} total number of subTokens for this analysis\n   */\n\n\n  _createClass(Analysis, [{\n    key: 'getSubToken',\n\n\n    // manipulate subTokens array\n\n    /**\n     * get subToken at the given index or null\n     *\n     * @param {Number} index\n     * @return {(null|Token)}\n     */\n    value: function getSubToken(index) {\n      return this.subTokens[index] || null;\n    }\n\n    /**\n     * insert a subToken BEFORE the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length), then it will be adjusted\n     *   to fit the bounds. this means that you can call this with `index=-Infinity`\n     *   to push to the front of the subTokens array or with `index=Infinity` to push\n     *   to the end\n     *\n     * @param {Number} index\n     * @param {Token} token\n     * @return {Analysis}\n     *\n     * @throws {NotatrixError} if given invalid index or analysis (see below)\n     */\n\n  }, {\n    key: 'insertSubTokenAt',\n    value: function insertSubTokenAt(index, token) {\n\n      // enforce only indices that can be cast as Numbers\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to insert subToken: unable to cast index to int');\n\n      // enforce token is a Token\n      if (!token) throw new NotatrixError('unable to insert subToken: no subToken provided');\n\n      // enforce token is a Token\n      if (token.__proto__ !== this.token.__proto__) // hacky, but don't have access to Token class\n        throw new NotatrixError('unable to insert subToken: not instance of Token');\n\n      // enforce not trying to add a superToken as a subToken\n      if (token.isSuperToken) throw new NotatrixError('unable to insert subToken: token has subTokens');\n\n      // enforce not trying to add a subToken of some other token\n      if (token.isSubToken) throw new NotatrixError('unable to insert subToken: token is already a subToken');\n\n      // enforce not trying to add a subToken to a subToken\n      if (this.isSubToken) throw new NotatrixError('unable to insert subToken: this is already a subToken');\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.length ? this.length : parseInt(index);\n\n      // set the superToken pointer on the token\n      token.superToken = this;\n\n      // array insertion\n      this.subTokens = this.subTokens.slice(0, index).concat(token).concat(this.subTokens.slice(index));\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * remove a subToken at the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length - 1), then it will be\n     *   adjusted to fit the bounds. this means that you can call this with\n     *   `index=-Infinity` to remove the first element of the subTokens array or\n     *   with `index=Infinity` to remove the last\n     *\n     * @param {Number} index\n     * @return {(null|Token)}\n     *\n     * @throws {NotatrixError} if given invalid index\n     */\n\n  }, {\n    key: 'removeSubTokenAt',\n    value: function removeSubTokenAt(index) {\n\n      // can't remove if we have an empty array\n      if (!this.length) return null;\n\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to remove subToken: unable to cast index to int');\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.length - 1 ? this.length - 1 : parseInt(index);\n\n      // remove the superToken pointer from the removed token\n      this.subTokens[index].superToken = null;\n\n      // array splicing, return spliced element\n      return this.subTokens.splice(index, 1)[0];\n    }\n\n    /**\n     * move a subToken from sourceIndex to targetIndex\n     *\n     * NOTE: if either index is out of bounds (<0 or >length - 1), then it will\n     *   be adjusted to fit the bounds. this means that you can call this with\n     *   `sourceIndex=-Infinity` to select the first element of the subTokens array\n     *   or with `sourceIndex=Infinity` to select the last\n     *\n     * @param {Number} sourceIndex\n     * @param {Number} targetIndex\n     * @return {Analysis}\n     *\n     * @throws {NotatrixError} if given invalid sourceIndex or targetIndex\n     */\n\n  }, {\n    key: 'moveSubTokenAt',\n    value: function moveSubTokenAt(sourceIndex, targetIndex) {\n\n      sourceIndex = parseFloat(sourceIndex);\n      targetIndex = parseFloat(targetIndex);\n      if (isNaN(sourceIndex) || isNaN(targetIndex)) throw new NotatrixError('unable to move subToken: unable to cast indices to ints');\n\n      // bounds checking\n      sourceIndex = sourceIndex < 0 ? 0 : sourceIndex > this.length - 1 ? this.length - 1 : parseInt(sourceIndex);\n      targetIndex = targetIndex < 0 ? 0 : targetIndex > this.length - 1 ? this.length - 1 : parseInt(targetIndex);\n\n      if (sourceIndex === targetIndex) {\n        // do nothing\n      } else {\n\n        // array splice and insert\n        var subToken = this.subTokens.splice(sourceIndex, 1);\n        this.subTokens = this.subTokens.slice(0, targetIndex).concat(subToken).concat(this.subTokens.slice(targetIndex));\n      }\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * push a subToken to the end of the subTokens array ... sugar for\n     *   Analysis::insertSubTokenAt(Infinity, analysis)\n     *\n     * @param {Token} token\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'pushSubToken',\n    value: function pushSubToken(token) {\n      return this.insertSubTokenAt(Infinity, token);\n    }\n\n    /**\n     * pop a subToken from the end of the subTokens array ... sugar for\n     *   Analysis::removeSubTokenAt(Infinity)\n     *\n     * @return {(null|Analysis)}\n     */\n\n  }, {\n    key: 'popSubToken',\n    value: function popSubToken() {\n      return this.removeSubTokenAt(Infinity);\n    }\n\n    // external formats\n\n    /**\n     * get a serial version of the internal analysis representation\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'eachHead',\n\n\n    // array-field (heads & deps) manipulators\n\n    /**\n     * iterate over the `head`s for this analysis and apply a callback to each\n     *\n     * @param {Function} callback\n     * @return {Analysis}\n     */\n    value: function eachHead(callback) {\n      _.each(this._heads, function (head, i) {\n        callback(head.token, head.deprel, i);\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * add a head on the given token with a dependency relation\n     *\n     * @param {Analysis} head pointer directly to the analysis\n     * @param {String} deprel\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'addHead',\n    value: function addHead(head, deprel) {\n      if (!(head instanceof Analysis)) throw new NotatrixError('can\\'t add head: not Analysis instance');\n\n      // first try to change an existing one (don't want duplicate heads)\n      if (this.changeHead(head, deprel)) return this;\n\n      // otherwise push a new one\n      this._heads.push({\n        token: head,\n        deprel: deprel\n      });\n\n      // if applicable, add to the head's deps field too\n      if (this.sentence.options.help.head) head._deps.push({\n        token: this,\n        deprel: deprel\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * remove a head from the given analysis if it exists\n     *\n     * @param {Analysis} head\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'removeHead',\n    value: function removeHead(head) {\n      var _this2 = this;\n\n      if (!(head instanceof Analysis)) throw new NotatrixError('can\\'t remove head: not Analysis instance');\n\n      // remove from _heads\n      var removing = -1;\n      this.eachHead(function (token, deprel, i) {\n        if (token === head) removing = i;\n      });\n      if (removing > -1) this._heads.splice(removing, 1);\n\n      // if applicable, also remove from head's _deps\n      removing = -1;\n      if (this.sentence.options.help.head) head.eachDep(function (token, deprel, i) {\n        if (token === _this2) removing = i;\n      });\n      if (removing > -1) head._deps.splice(removing, 1);\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * change the dependency relation for a given head ... returns null if unable\n     *   to make the change\n     *\n     * @param {Analysis} head\n     * @param {String} deprel\n     * @return {(Analysis|null)}\n     */\n\n  }, {\n    key: 'changeHead',\n    value: function changeHead(head, deprel) {\n      var _this3 = this;\n\n      if (!(head instanceof Analysis)) throw new NotatrixError('can\\'t change head: not Analysis instance');\n\n      // change for this head\n      var done = false;\n      this.eachHead(function (token, _deprel, i) {\n        if (token === head) {\n          _this3._heads[i].deprel = deprel || _deprel;\n          done = true;\n        }\n      });\n\n      // if applicable, change for the head's dep too\n      if (this.sentence.options.help.head) head.eachDep(function (token, _deprel, i) {\n        if (token === _this3) head._deps[i].deprel = deprel || _deprel;\n      });\n\n      return done ? this : null;\n    }\n\n    /**\n     * iterate over the `deps`s for this analysis and apply a callback to each\n     *\n     * @param {Function} callback\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'eachDep',\n    value: function eachDep(callback) {\n      _.each(this._deps, function (dep, i) {\n        callback(dep.token, dep.deprel, i);\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * add a dep on the given token with a dependency relation\n     *\n     * @param {Analysis} dep pointer directly to the analysis\n     * @param {String} deprel\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'addDep',\n    value: function addDep(dep, deprel) {\n      if (!(dep instanceof Analysis)) throw new NotatrixError('can\\'t add dep: not Analysis instance');\n\n      // first try to change an existing one (don't want duplicate deps)\n      if (this.changeDep(dep, deprel)) return this;\n\n      // otherwise push a new one\n      this._deps.push({\n        token: dep,\n        deprel: deprel\n      });\n\n      // if applicable, add to the dep's head field too\n      if (this.sentence.options.help.deps) dep._heads.push({\n        token: this,\n        deprel: deprel\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * remove a dep from the given analysis if it exists\n     *\n     * @param {Analysis} dep\n     * @return {Analysis}\n     */\n\n  }, {\n    key: 'removeDep',\n    value: function removeDep(dep) {\n      var _this4 = this;\n\n      if (!(dep instanceof Analysis)) throw new NotatrixError('can\\'t remove dep: not Analysis instance');\n\n      // remove from _deps\n      var removing = -1;\n      this.eachDep(function (token, deprel, i) {\n        if (token === dep) removing = i;\n      });\n      if (removing > -1) this._deps.splice(removing, 1);\n\n      // if applicable, also remove from dep's _heads\n      removing = -1;\n      if (this.sentence.options.help.deps) dep.eachHead(function (token, deprel, i) {\n        if (token === _this4) removing = i;\n      });\n      if (removing > -1) dep._heads.splice(removing, 1);\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * change the dependency relation for a given dep ... returns null if unable\n     *   to make the change\n     *\n     * @param {Analysis} dep\n     * @param {String} deprel\n     * @return {(Analysis|null)}\n     */\n\n  }, {\n    key: 'changeDep',\n    value: function changeDep(dep, deprel) {\n      var _this5 = this;\n\n      if (!(dep instanceof Analysis)) throw new NotatrixError('can\\'t change dep: not Analysis instance');\n\n      // change for this dep\n      var done = false;\n      this.eachDep(function (token, _deprel, i) {\n        if (token === dep) {\n          _this5._deps[i].deprel = deprel || _deprel;\n          done = true;\n        }\n      });\n\n      // if applicable, change for the dep's head too\n      if (this.sentence.options.help.deps) dep.eachHead(function (token, _deprel, i) {\n        if (token === _this5) dep._heads[i].deprel = deprel || _deprel;\n      });\n\n      return done ? this : null;\n    }\n\n    // field getters and setters\n\n    /**\n     * get the `form` ... if none defined, `help.form` setting `= true` (default:\n     *   `true`), and `lemma` is set, return `lemma` instead\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.subTokens.length;\n    }\n  }, {\n    key: 'nx',\n    get: function get() {\n      var _this6 = this;\n\n      // serialize \"values\" (getter/setter version of fields)\n      var values = {};\n      _.each(fields, function (field) {\n        values[field] = _this6[field];\n      });\n\n      // serialize other data\n      return {\n        id: this.id,\n        params: this.params,\n        values: values,\n        subTokens: this.subTokens.map(function (subToken) {\n          return subToken.nx;\n        })\n      };\n    }\n\n    /**\n     * get a plain-text formatted string of the analysis\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n\n      // first check if we have a form\n      if (this.form && this.form !== fallback) return this.form;\n\n      // fall back to using lemma\n      if (this.lemma && this.lemma !== fallback) return this.lemma;\n\n      // fall back to our fallback (defined above)\n      return fallback;\n    }\n\n    /**\n     * get a CoNLL-U formatted string representing the analysis\n     *\n     * @return {String}\n     *\n     * @throws {NotatrixError} if id has not been set\n     */\n\n  }, {\n    key: 'conllu',\n    get: function get() {\n      var _this7 = this;\n\n      // reindex just in case since this is crucial\n      this.sentence.index();\n\n      // we can't output CoNLL-U for analyses that aren't indexed, since that\n      //   means they're not in the current analysis\n      if (this.id === null || this.id === undefined) throw new NotatrixError('analysis is not currently indexed');\n\n      // return a tab-delimited string with the information contained in each field\n      //   and the index out front\n      return this.id + '\\t' + _.map(fields, function (field) {\n\n        // if we have no data for a field, use our fallback to maintain\n        //   the correct matrix structure\n        return _this7[field] || fallback;\n      }).join('\\t');\n    }\n\n    /**\n     * get a CG3 formatted string representing the analysis\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'cg3',\n    get: function get() {\n\n      // reindex just in case since this is crucial\n      this.sentence.index();\n\n      // either output this analysis or its subTokens\n      if (this.isSuperToken) {\n        return this.subTokens.map(function (subToken, i) {\n\n          // recall subTokens get hanging indents\n          return cg3FormatOutput(subToken.analysis, i + 1);\n        }).join('\\n');\n      } else {\n\n        // regular tokens get an index of 1\n        return cg3FormatOutput(this, 1);\n      }\n    }\n  }, {\n    key: 'eles',\n    get: function get() {\n      throw new Error('Analysis::eles [get] is not implemented'); // TODO\n    }\n  }, {\n    key: 'form',\n    get: function get() {\n      return this.sentence.options.help.form ? this._form || this._lemma : this._form;\n    }\n\n    /**\n     * set the `form` ... if the form is just punctuation, possibly set the pos tags\n     *   to `PUNCT` (see {@link evaluatePunctPos})\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(form) {\n      form = sanitize(form);\n      evaluatePunctPos(this, form);\n      this._form = form;\n    }\n\n    /**\n     * get the `lemma` ... if none defined, `help.lemma` setting `= true` (default:\n     *   `true`), and `form` is set, return `form` instead\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'lemma',\n    get: function get() {\n      return this.sentence.options.help.lemma ? this._lemma || this._form : this._lemma;\n    }\n\n    /**\n     * set the `lemma` ... if the lemma is just punctuation, possibly set the pos tags\n     *   to `PUNCT` (see {@link evaluatePunctPos})\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(lemma) {\n      lemma = sanitize(lemma);\n      evaluatePunctPos(this, lemma);\n      this._lemma = lemma;\n    }\n\n    /**\n     * get the `pos`, which is just `upostag || xpostag`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'pos',\n    get: function get() {\n      return this.upostag || this.xpostag;\n    }\n\n    /**\n     * get the `upostag`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'upostag',\n    get: function get() {\n      return this._upostag;\n    }\n\n    /**\n     * set the `upostag`\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(upostag) {\n      this._upostag = sanitize(upostag);\n    }\n\n    /**\n     * get the `xpostag`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'xpostag',\n    get: function get() {\n      return this._xpostag;\n    }\n\n    /**\n     * set the `xpostag`\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(xpostag) {\n      this._xpostag = sanitize(xpostag);\n    }\n\n    /**\n     * get the `feats`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'feats',\n    get: function get() {\n      return this._feats;\n    }\n\n    /**\n     * set the `feats`\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(feats) {\n      this._feats = sanitize(feats);\n    }\n\n    /**\n     * get the `head` ... if the `showEnhanced` setting `= true` (default: `true`)\n     *   will return a `|`-delimited list of `index`:`deprel` pairs\n     *\n     * @return {(String)}\n     */\n\n  }, {\n    key: 'head',\n    get: function get() {\n      var _this8 = this;\n\n      if (this.sentence.options.showEnhanced) {\n        var heads = [];\n        this.eachHead(function (token, deprel) {\n          if (token === _this8.sentence.getById(token.id) || !_this8.sentence.options.help.head) {\n            heads.push('' + (token.id || token) + (deprel ? ':' + deprel : ''));\n          } else {\n            heads.push('' + token + (deprel ? ':' + deprel : ''));\n          }\n        });\n        return heads.join('|');\n      } else {\n        return this._heads.length ? this._heads[0].id || this._heads[0] : null;\n      }\n    }\n\n    /**\n     * set the `head` ... if the `Analysis` is `initializing`, just save a plain\n     *   string, otherwise try to get the head by index (see {@link Sentence#getById})\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(heads) {\n      var _this9 = this;\n\n      if (typeof heads === 'string') heads = parseEnhancedString(heads);\n\n      this._heads = heads.map(function (head) {\n        return _this9.initializing ? {\n          token: head.token,\n          deprel: head.deprel\n        } : {\n          token: _this9.sentence.getById(head.token) || head.token,\n          deprel: head.deprel\n        };\n      });\n    }\n\n    /**\n     * get the `deprel`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'deprel',\n    get: function get() {\n      return this._deprel;\n    }\n\n    /**\n     * set the `deprel`\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(deprel) {\n      this._deprel = sanitize(deprel);\n    }\n\n    /**\n     * get the `deps` returns a `|`-delimited list of `index`:`deprel` pairs\n     *\n     * @return {(String)}\n     */\n\n  }, {\n    key: 'deps',\n    get: function get() {\n      var _this10 = this;\n\n      // don't worry about enhanced stuff for deps (always can be multiple)\n      var deps = [];\n      this.eachDep(function (token, deprel) {\n        if (token === _this10.sentence.getById(token.id) || !_this10.sentence.options.help.deps) deps.push('' + (token.id || token) + (deprel ? ':' + deprel : ''));\n      });\n      return deps.join('|');\n    }\n\n    /**\n     * set the `deps` ... if the `Analysis` is `initializing`, just save a plain\n     *   string, otherwise try to get the dep by index (see {@link Sentence#getById})\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(deps) {\n      var _this11 = this;\n\n      if (typeof deps === 'string') deps = parseEnhancedString(deps);\n\n      this._deps = deps.map(function (dep) {\n        return _this11.initializing ? {\n          token: dep.token,\n          deprel: dep.deprel\n        } : {\n          token: _this11.sentence.getById(dep.token) || dep.token,\n          deprel: dep.deprel\n        };\n      });\n    }\n\n    /**\n     * get the `misc`\n     *\n     * @return {(String|undefined)}\n     */\n\n  }, {\n    key: 'misc',\n    get: function get() {\n      return this._misc;\n    }\n\n    /**\n     * set the `misc`\n     *\n     * @return {undefined}\n     */\n    ,\n    set: function set(misc) {\n      this._misc = sanitize(misc);\n    }\n\n    // bool stuff\n\n    /**\n     * returns this analysis's superToken if it exists\n     *\n     * @return {(Token|null)}\n     */\n\n  }, {\n    key: 'superToken',\n    get: function get() {\n      return this.token.superToken;\n    }\n\n    /**\n     * returns true iff this analysis is a subToken of some other token\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSubToken',\n    get: function get() {\n      return this.superToken !== null;\n    }\n\n    /**\n     * returns true iff this analysis has subTokens\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSuperToken',\n    get: function get() {\n      return this.subTokens.length > 0;\n    }\n\n    /**\n     * returns true iff this analysis is the current analysis\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isCurrent',\n    get: function get() {\n      return this.token.analysis === this;\n    }\n  }]);\n\n  return Analysis;\n}(Object);\n\n/**\n * Proxy so that we can get subTokens using Array-like syntax\n *\n * NOTE: usage: `ana[8]` would return the analysis of the subToken at index 8\n * NOTE: if `name` is not a Number, fall through to normal object\n *\n * @return {Mixed}\n * @name Analysis#get\n */\n\n\nAnalysis.prototype.__proto__ = new Proxy(Analysis.prototype.__proto__, {\n\n  // default getter, called any time we use Analysis.name or Analysis[name]\n  get: function get(target, name, receiver) {\n\n    // Symbols can't be cast to floats, so check here to avoid errors\n    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'symbol') return this[name];\n\n    // cast, catch Infinity\n    var id = parseFloat(name);\n    if (!isNaN(id)) {\n\n      // if we got a number, return analysis of subToken at that index\n      id = parseInt(id);\n      var token = receiver.subTokens[id];\n      return token ? token.analysis : null;\n    } else {\n\n      // fall through to normal getting\n      return this[name];\n    }\n  }\n});\n\n// expose to application\nmodule.exports = Analysis;\n\n},{\"./errors\":3,\"underscore\":1}],3:[function(require,module,exports){\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar NotatrixError = function (_Error) {\n  _inherits(NotatrixError, _Error);\n\n  function NotatrixError() {\n    var _ref;\n\n    _classCallCheck(this, NotatrixError);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _possibleConstructorReturn(this, (_ref = NotatrixError.__proto__ || Object.getPrototypeOf(NotatrixError)).call.apply(_ref, [this].concat(args)));\n  }\n\n  return NotatrixError;\n}(Error);\n\nvar InvalidCG3Error = function (_NotatrixError) {\n  _inherits(InvalidCG3Error, _NotatrixError);\n\n  function InvalidCG3Error() {\n    var _ref2;\n\n    _classCallCheck(this, InvalidCG3Error);\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return _possibleConstructorReturn(this, (_ref2 = InvalidCG3Error.__proto__ || Object.getPrototypeOf(InvalidCG3Error)).call.apply(_ref2, [this].concat(args)));\n  }\n\n  return InvalidCG3Error;\n}(NotatrixError);\n\nvar InvalidCoNLLUError = function (_NotatrixError2) {\n  _inherits(InvalidCoNLLUError, _NotatrixError2);\n\n  function InvalidCoNLLUError() {\n    var _ref3;\n\n    _classCallCheck(this, InvalidCoNLLUError);\n\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return _possibleConstructorReturn(this, (_ref3 = InvalidCoNLLUError.__proto__ || Object.getPrototypeOf(InvalidCoNLLUError)).call.apply(_ref3, [this].concat(args)));\n  }\n\n  return InvalidCoNLLUError;\n}(NotatrixError);\n\nvar TransformationError = function (_NotatrixError3) {\n  _inherits(TransformationError, _NotatrixError3);\n\n  function TransformationError() {\n    var _ref4;\n\n    _classCallCheck(this, TransformationError);\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return _possibleConstructorReturn(this, (_ref4 = TransformationError.__proto__ || Object.getPrototypeOf(TransformationError)).call.apply(_ref4, [this].concat(args)));\n  }\n\n  return TransformationError;\n}(NotatrixError);\n\nmodule.exports = {\n\n  NotatrixError: NotatrixError,\n  InvalidCG3Error: InvalidCG3Error,\n  InvalidCoNLLUError: InvalidCoNLLUError,\n  TransformationError: TransformationError\n\n};\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n\n  'Error': require('./errors'),\n  Sentence: require('./sentence'),\n  Token: require('./token'),\n  Analysis: require('./analysis')\n\n};\n\n},{\"./analysis\":2,\"./errors\":3,\"./sentence\":5,\"./token\":6}],5:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _ = require('underscore');\n\nvar NotatrixError = require('./errors').NotatrixError;\nvar InvalidCG3Error = require('./errors').InvalidCG3Error;\nvar InvalidCoNLLUError = require('./errors').InvalidCoNLLUError;\n\nvar Token = require('./token');\n\n// define all the regex we use in this module here\nvar regex = {\n  comment: /^\\W*\\#/,\n  commentContent: /^\\W*\\#\\W*(.*)/,\n  superToken: /^\\W*[0-9.]+\\-[0-9.]+/,\n  empty: /^\\W*[0-9]+\\.[0-9]+/,\n  cg3TokenStart: /^\"<(.|\\\\\")*>\"/,\n  cg3TokenContent: /^;?\\s+\"(.|\\\\\")*\"/\n\n  /**\n   * this class contains all the information associated with a sentence, including\n   *   an comments array, a tokens array, and a list of options/settings that apply\n   *   to all subelements of this sentence\n   */\n};\nvar Sentence = function (_Object) {\n  _inherits(Sentence, _Object);\n\n  function Sentence(paramsList, options) {\n    _classCallCheck(this, Sentence);\n\n    // handle only receiving one arg better\n    var _this = _possibleConstructorReturn(this, (Sentence.__proto__ || Object.getPrototypeOf(Sentence)).call(this));\n\n    if (options === undefined && !Array.isArray(paramsList)) {\n      options = paramsList;\n      paramsList = undefined;\n    }\n\n    // save sentence-wide settings here\n    _this.options = _.defaults(options, {\n      help: {\n        form: true,\n        lemma: true,\n        upostag: true,\n        xpostag: true,\n        head: true,\n        deps: true\n      },\n      prettyOutput: true,\n      showEnhanced: true,\n      showEmptyDependencies: true\n    });\n\n    // the actual data\n    _this.comments = [];\n    _this.tokens = [];\n\n    // try parsing a list of parameters\n    if (paramsList) _this.params = paramsList;\n    return _this;\n  }\n  /**\n   * @return {Number} total number of tokens/subTokens in this sentence\n   */\n\n\n  _createClass(Sentence, [{\n    key: 'forEach',\n\n    /**\n     * loop through every token in the sentence and apply a callback\n     *\n     * @param {Function} callback function to be applied to every token\n     * @return {Sentence}\n     */\n    value: function forEach(callback) {\n\n      var t = 0;\n      for (var i = 0; i < this.tokens.length; i++) {\n        var token = this.tokens[i];\n        callback(token, t);\n        t++;\n        for (var j = 0; j < token.subTokens.length; j++) {\n          callback(token.subTokens[j], t);\n          t++;\n        }\n      }\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * return the comment at the given index, or null\n     *\n     * @param {Number} index\n     * @return {(String|null)}\n     */\n\n  }, {\n    key: 'getComment',\n    value: function getComment(index) {\n      return this.comments[index] || null;\n    }\n\n    /**\n     * return the token at the given index (note: this is regular token OR subToken),\n     *   or null.  to choose by superToken index, use Sentence[index] syntax.  this\n     *   function assumes only the current analysis is desired.\n     *\n     * @param {Number} index\n     * @return {(Token|null)}\n     */\n\n  }, {\n    key: 'getToken',\n    value: function getToken(index) {\n      var t = 0,\n          token = null;\n      this.forEach(function (tok, t) {\n        if (t === index) token = tok;\n      });\n      return token;\n    }\n\n    /**\n     * return the current analysis of the token that matches a given index string\n     *\n     * NOTE: tokens outside the current analysis will have id=null and cannot be retrieved\n     *   with this function\n     *\n     * @param {String} index\n     * @return {(Analysis|null)}\n     */\n\n  }, {\n    key: 'getById',\n    value: function getById(index) {\n      for (var i = 0; i < this.tokens.length; i++) {\n        var token = this.tokens[i];\n        if (token.analysis.id == index) return token.analysis;\n        for (var j = 0; j < token.subTokens.length; j++) {\n          var subToken = token.subTokens[j];\n          if (subToken.analysis.id == index) return subToken.analysis;\n        }\n      }\n      return null;\n    }\n\n    // manipulate token array\n\n    /**\n     * insert a token BEFORE the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length), then it will be adjusted\n     *   to fit the bounds. this means that you can call this with `index=-Infinity`\n     *   to push to the front of the tokens array or with `index=Infinity` to push\n     *   to the end\n     *\n     * @param {Number} index\n     * @param {Token} token\n     * @return {Sentence}\n     *\n     * @throws {NotatrixError} if given invalid index or token\n     */\n\n  }, {\n    key: 'insertTokenAt',\n    value: function insertTokenAt(index, token) {\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to insert token: unable to cast index to int');\n\n      if (!(token instanceof Token)) throw new NotatrixError('unable to insert token: not instance of Token');\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.length ? this.length : parseInt(index);\n\n      // array insertion\n      this.tokens = this.tokens.slice(0, index).concat(token).concat(this.tokens.slice(index));\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * remove a token at the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length - 1), then it will be\n     *   adjusted to fit the bounds. this means that you can call this with\n     *   `index=-Infinity` to remove the first element of the tokens array or\n     *   with `index=Infinity` to remove the last\n     *\n     * @param {Number} index\n     * @return {(Token|null)}\n     *\n     * @throws {NotatrixError} if given invalid index\n     */\n\n  }, {\n    key: 'removeTokenAt',\n    value: function removeTokenAt(index) {\n      // can't remove if we have an empty sentence\n      if (!this.tokens.length) return null;\n\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to remove token: unable to cast index to int');\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.tokens.length - 1 ? this.tokens.length - 1 : parseInt(index);\n\n      // array splicing, return spliced element\n      return this.tokens.splice(index, 1)[0];\n    }\n\n    /**\n     * move a token from sourceIndex to targetIndex\n     *\n     * NOTE: if either index is out of bounds (<0 or >length - 1), then it will\n     *   be adjusted to fit the bounds. this means that you can call this with\n     *   `sourceIndex=-Infinity` to select the first element of the tokens array\n     *   or with `sourceIndex=Infinity` to select the last\n     *\n     * @param {Number} sourceIndex\n     * @param {Number} targetIndex\n     * @return {Sentence}\n     *\n     * @throws {NotatrixError} if given invalid sourceIndex or targetIndex\n     */\n\n  }, {\n    key: 'moveTokenAt',\n    value: function moveTokenAt(sourceIndex, targetIndex) {\n      sourceIndex = parseFloat(sourceIndex);\n      targetIndex = parseFloat(targetIndex);\n      if (isNaN(sourceIndex) || isNaN(targetIndex)) throw new NotatrixError('unable to move token: unable to cast indices to ints');\n\n      // bounds checking\n      sourceIndex = sourceIndex < 0 ? 0 : sourceIndex > this.tokens.length - 1 ? this.tokens.length - 1 : parseInt(sourceIndex);\n      targetIndex = targetIndex < 0 ? 0 : targetIndex > this.tokens.length - 1 ? this.tokens.length - 1 : parseInt(targetIndex);\n\n      if (sourceIndex === targetIndex) {\n        // do nothing\n      } else {\n\n        // array splice and insert\n        var token = this.tokens.splice(sourceIndex, 1);\n        this.tokens = this.tokens.slice(0, targetIndex).concat(token).concat(this.tokens.slice(targetIndex));\n      }\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * push a token to the end of the tokens array ... sugar for\n     *   Sentence::insertTokenAt(Infinity, token)\n     *\n     * @param {Token} token\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'pushToken',\n    value: function pushToken(token) {\n      return this.insertTokenAt(Infinity, token);\n    }\n\n    /**\n     * pop a token from the end of the tokens array ... sugar for\n     *   Sentence::removeTokenAt(Infinity)\n     *\n     * @return {(Token|null)}\n     */\n\n  }, {\n    key: 'popToken',\n    value: function popToken() {\n      return this.removeTokenAt(Infinity);\n    }\n\n    // external formats\n\n    /**\n     * get a serial version of the internal sentence representation\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'clean',\n    value: function clean() {\n      throw new Error('Sentence::clean is not implemented'); // TODO\n    }\n\n    /**\n     * iterate through the tokens and set an appropriate index for each (following\n     *   CoNLL-U indexing scheme with, e.g. 1 for regular token, 1-2 for superToken,\n     *   1.1 for \"empty\" token)\n     *\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'index',\n    value: function index() {\n      // track \"overall\" index number (id) and \"empty\" index number\n      // NOTE: CoNLL-U indices start at 1 (0 is root), so we will increment this\n      //   index before using it (see Token::index)\n      var id = 0,\n          empty = 0;\n      _.each(this.tokens, function (token) {\n        var _token$index = token.index(id, empty);\n        // allow each token to return counters for the next guy\n\n\n        var _token$index2 = _slicedToArray(_token$index, 2);\n\n        id = _token$index2[0];\n        empty = _token$index2[1];\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * iterate through the tokens and try to convert a plain string index to a\n     *   head to the actual token given by that index (called after parsing\n     *   CoNLL-U, CG3, or params)\n     *\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'attach',\n    value: function attach() {\n      // reindex in case we're out of date (valid index is crucial here)\n      this.index();\n      this.forEach(function (token) {\n        token.analysis.head = token.analysis.head;\n        token.analysis.deps = token.analysis.deps;\n      });\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * iterate through the tokens and determine if they could be converted into\n     *   a CoNLL-U formatted string\n     *\n     * NOTE: currently, only returns false if it contains one/more ambiguous analyses\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n\n      var acc = 0;\n      this.forEach(function (token) {\n        acc++;\n      });\n      return acc;\n    }\n  }, {\n    key: 'nx',\n    get: function get() {\n      // update indices\n      this.index();\n\n      // serialize tokens\n      var tokens = [];\n      for (var i = 0; i < this.tokens.length; i++) {\n        tokens.push(this.tokens[i].nx);\n      }\n\n      // serialize other data\n      return JSON.stringify({\n        comments: this.comments,\n        options: this.options,\n        tokens: tokens\n      }, null, this.options.prettyOutput ? 2 : 0);\n    }\n\n    /**\n     * get a plain-text formatted string of the sentence's current analysis text\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      // only care about tokens (not comments or settings)\n      var tokens = [];\n      this.forEach(function (token) {\n        if (!token.isSubToken && !token.isEmpty) tokens.push(token.text);\n      });\n      return tokens.join(' ');\n    }\n\n    /**\n     * get a CoNLL-U formatted string representing the sentence's current analysis\n     *\n     * @return {(String|null)}\n     */\n\n  }, {\n    key: 'conllu',\n    get: function get() {\n      // comments first\n      var comments = _.map(this.comments, function (comment) {\n        return '# ' + comment;\n      });\n\n      try {\n\n        var tokens = [];\n        this.forEach(function (token) {\n          tokens.push(token.conllu);\n        });\n        return comments.concat(tokens).join('\\n');\n      } catch (e) {\n\n        // if the sentence contains ambiguous analyses, we will get an error,\n        // so catch only those types of errors here\n        if (!(e instanceof InvalidCoNLLUError)) throw e;\n\n        // if sentence is ambiguous\n        return null;\n      }\n    }\n\n    /**\n     * parse a CoNLL-U formatted string and save its contents to the sentence\n     *\n     * @param {String} conllu\n     * @return {String}\n     */\n    ,\n    set: function set(conllu) {\n      // clear existing data\n      this.comments = [];\n      this.tokens = [];\n\n      // split on newlines\n      var lines = conllu.trim().split('\\n');\n      for (var i = 0; i < lines.length; i++) {\n\n        // extract comments\n        if (regex.comment.test(lines[i])) {\n          this.comments.push(lines[i].match(regex.commentContent)[1]);\n\n          // extract tokens\n        } else if (regex.superToken.test(lines[i])) {\n\n          // the top-level token\n          var superToken = Token.fromConllu(this, lines[i]);\n\n          // check which subTokens belong to this superToken\n          var k = i;\n          var subTokenIndices = lines[i].match(regex.superToken)[0].trim().split('-').map(function (str) {\n            return parseInt(str);\n          });\n\n          // push them all to the superToken's current analysis\n          for (var j = 0; j <= subTokenIndices[1] - subTokenIndices[0]; j++) {\n            superToken.analysis.pushSubToken(Token.fromConllu(this, lines[j + k + 1]));\n            i++;\n          }\n\n          // push the superToken to the sentence\n          this.pushToken(superToken);\n        } else {\n\n          // regular (non-super) tokens pushed to sentence here\n          if (lines[i].trim().length) this.pushToken(Token.fromConllu(this, lines[i]));\n        }\n      }\n\n      // attach heads and return CoNLL-U string\n      return this.attach().conllu;\n    }\n\n    /**\n     * static method allowing us to construct a new Sentence directly from a\n     *   CoNLL-U string\n     *\n     * @param {String} serial\n     * @param {Object} options (optional)\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'cg3',\n\n\n    /**\n     * get a CG3 formatted string representing all of the sentence's analyses\n     *\n     * @return {(String|null)}\n     */\n    get: function get() {\n      // comments first\n      var comments = _.map(this.comments, function (comment) {\n        return '# ' + comment;\n      });\n\n      try {\n\n        var tokens = [];\n        for (var i = 0; i < this.tokens.length; i++) {\n          // iterate over superTokens\n          tokens.push(this.tokens[i].cg3);\n        }\n        return comments.concat(tokens).join('\\n');\n      } catch (e) {\n\n        // if the sentence is not analyzeable as CG3, we'll get an error\n        // NOTE: this doesn't currently happen under any circumstances\n        if (!(e instanceof InvalidCG3Error)) throw e;\n\n        return null;\n      }\n    }\n\n    /**\n     * parse a CG3 formatted string and save its contents to the sentence\n     *\n     * @param {String} conllu\n     * @return {String}\n     */\n    ,\n    set: function set(cg3) {\n      // clear existing data\n      this.comments = [];\n      this.tokens = [];\n\n      // since this parsing is more complicated than CoNLL-U parsing, keep this\n      //   array of lines for the current token we're parsing\n      // NOTE: CG3 tokens are separated by lines of the form `/^\"<EXAMPLE>\"/`\n      //   and lines beginning with one/more indent give data for that token\n      var tokenLines = [];\n\n      // split on newlines\n      var lines = cg3.trim().split('\\n');\n      for (var i = 0; i < lines.length; i++) {\n\n        // decide what the current line is\n        var isToken = regex.cg3TokenStart.test(lines[i]);\n        var isContent = regex.cg3TokenContent.test(lines[i]);\n\n        // current line is the start of a new token\n        if (isToken) {\n\n          // if we already have stuff in our tokenLines buffer, parse it as a token\n          if (tokenLines.length) this.tokens.push(Token.fromCG3(this, tokenLines));\n\n          // reset tokenLines buffer\n          tokenLines = [lines[i]];\n        } else {\n\n          // add content lines to tokenLines buffer\n          if (tokenLines.length && isContent) {\n            tokenLines.push(lines[i]);\n\n            // push comment\n          } else {\n            this.comments.push(lines[i].match(regex.commentContent)[1]);\n          }\n        }\n      }\n\n      // clear tokenLines buffer\n      if (tokenLines.length) this.tokens.push(Token.fromCG3(this, tokenLines));\n\n      // attach heads and return CG3 string\n      return this.attach().cg3;\n    }\n\n    /**\n     * static method allowing us to construct a new Sentence directly from a\n     *   CG3 string\n     *\n     * @param {String} serial\n     * @param {Object} options (optional)\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'params',\n\n\n    /**\n     * get an array of token parameters representing the sentence\n     *\n     * NOTE: fails (returns null) if we have subTokens or ambiguous analyses\n     *\n     * @return {(Array|null)}\n     */\n    get: function get() {\n      try {\n\n        var params = [];\n        this.forEach(function (token) {\n\n          if (token.isSuperToken || token.isSubToken) throw new InvalidCoNLLUError();\n          if (token.isAmbiguous) throw new InvalidCG3Error();\n\n          params.push(token.params);\n        });\n        return params;\n      } catch (e) {\n        if (e instanceof InvalidCoNLLUError) {\n          console.warn('cannot get params for this sentence: contains MultiWordTokens');\n          return null;\n        } else if (e instanceof InvalidCG3Error) {\n          console.warn('cannot get params for this sentence: contains ambiguous analyses');\n          return null;\n        } else {\n          // throw other errors\n          throw e;\n        }\n      }\n    }\n\n    /**\n     * parse an array of token parameters and save contents to the sentence\n     *\n     * @param {Array} paramsList\n     * @return {(Array|null)}\n     */\n    ,\n    set: function set(paramsList) {\n      var _this2 = this;\n\n      // can only parse arrays\n      if (!(paramsList instanceof Array)) return null;\n\n      // clear existing data\n      this.comments = [];\n      this.tokens = [];\n\n      // push a new token for each set of parameters\n      _.each(paramsList, function (params) {\n        _this2.tokens.push(Token.fromParams(_this2, params));\n      });\n\n      // attach heads and return validated parameter list\n      return this.attach().params;\n    }\n\n    /**\n     * static method allowing us to construct a new Sentence directly from an\n     *   array of parameters\n     *\n     * @param {Array} paramsList\n     * @param {Object} options (optional)\n     * @return {Sentence}\n     */\n\n  }, {\n    key: 'eles',\n    get: function get() {\n      throw new Error('Sentence::eles [get] is not implemented'); // TODO\n    }\n  }, {\n    key: 'isValidConllu',\n    get: function get() {\n      var valid = true;\n      this.forEach(function (token) {\n        if (token.isAmbiguous) valid = false;\n      });\n      return valid;\n    }\n\n    /**\n     * iterate through the tokens and determine if they could be converted into\n     *   a CG3 formatted string\n     *\n     * NOTE: currently, always returns true (see update below)\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isValidCG3',\n    get: function get() {\n      var valid = true;\n      this.forEach(function (token) {\n        /*\n        UPDATE 6/9/18: apparently CG3 can handle all this stuff, it's just a bit lossy\n          (e.g. subTokens won't have their own `form` and `empty` tokens won't show up)\n         if (token.isSubToken || token.isSuperToken || token.isEmpty)\n          valid = false;\n        */\n      });\n      return valid;\n    }\n  }], [{\n    key: 'fromConllu',\n    value: function fromConllu(serial, options) {\n      var sent = new Sentence(options);\n      sent.conllu = serial;\n      return sent;\n    }\n  }, {\n    key: 'fromCG3',\n    value: function fromCG3(serial, options) {\n      var sent = new Sentence(options);\n      sent.cg3 = serial;\n      return sent;\n    }\n  }, {\n    key: 'fromParams',\n    value: function fromParams(paramsList, options) {\n      var sent = new Sentence(options);\n      sent.params = paramsList;\n      return sent;\n    }\n  }]);\n\n  return Sentence;\n}(Object);\n\n/**\n * Proxy so that we can get tokens using Array-like syntax\n *\n * NOTE: usage: `sent[8]` would return the analysis of the token at index 8\n * NOTE: if `name` is not a Number, fall through to normal object\n *\n * @return {Mixed}\n * @name Sentence#get\n */\n\n\nSentence.prototype.__proto__ = new Proxy(Sentence.prototype.__proto__, {\n\n  // default getter, called any time we use Sentence.name or Sentence[name]\n  get: function get(target, name, receiver) {\n\n    // Symbols can't be cast to floats, so check here to avoid errors\n    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'symbol') return this[name];\n\n    // cast, catch Infinity\n    var id = parseFloat(name);\n    if (!isNaN(id)) {\n\n      // if we got a number, return analysis at that index\n      id = parseInt(id);\n      var token = receiver.tokens[id];\n      return token ? token.analysis : null;\n    } else {\n\n      // fall through to normal getting\n      return this[name];\n    }\n  }\n});\n\n// expose to application\nmodule.exports = Sentence;\n\n},{\"./errors\":3,\"./token\":6,\"underscore\":1}],6:[function(require,module,exports){\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _ = require('underscore');\n\nvar NotatrixError = require('./errors').NotatrixError;\nvar InvalidCG3Error = require('./errors').InvalidCG3Error;\nvar InvalidCoNLLUError = require('./errors').InvalidCoNLLUError;\n\nvar Analysis = require('./analysis');\n\n/**\n * helper function to split on whitespace\n *\n * @param {String} str\n * @return {Array}\n */\nfunction split(str) {\n  return (str || '').split(/\\s+/);\n}\n\n/**\n * helper function to count the number of leading `\\t` characters in a string\n *\n * @param {String} line\n * @return {Number}\n */\nfunction getIndent(line) {\n\n  var chars = line.split(''),\n      i = 0;\n\n  while (chars[i++] === '\\t') {\n    true;\n  } // do nothing\n\n  return i - 1;\n}\n\n// CG3 parser helper functions\n\n/**\n * extract the `form` parameter from a given string\n *\n * @param {String} line\n * @return {(undefined|String)}\n */\nfunction cg3StringGetForm(line) {\n\n  return cg3Regex.form.test(line) ? line.match(cg3Regex.form)[1] : undefined;\n}\n\n/**\n * extract all the other (not `form`) tags from a given string\n *\n * @param {String} line\n * @return {Object}\n */\nfunction cg3StringGetTags(line) {\n\n  // initialize things\n  var lemma = void 0,\n      xpostag = [],\n      head = void 0,\n      deprel = void 0,\n      deps = void 0,\n      misc = [];\n\n  // get lemma\n  if (cg3Regex.lemma.test(line)) lemma = line.match(cg3Regex.lemma)[1];\n\n  // only consider line after lemma (if it exists)\n  line = lemma ? line.slice(line.indexOf(lemma) + lemma.length + 1).trim() : line;\n\n  // split on whitespace\n  var chunks = split(line);\n\n  // iterate over each chunk\n  for (var j = 0; j < chunks.length; j++) {\n\n    // try to extract deprel\n    if (cg3Regex.deprel.test(chunks[j])) {\n      deprel = chunks[j].match(cg3Regex.deprel)[1];\n\n      // try to extract head\n    } else if (cg3Regex.dependency.test(chunks[j])) {\n      head = chunks[j].match(cg3Regex.dependency)[2];\n\n      // try to extract misc, track with array (can be multiple)\n    } else if (cg3Regex.misc.test(chunks[j])) {\n      misc.push(chunks[j]);\n\n      // try to extract tags (and save to xpostag), track with an array (can be multiple)\n    } else {\n      xpostag.push(chunks[j]);\n    }\n  }\n\n  // return our extracted data\n  return {\n    lemma: lemma,\n    xpostag: xpostag.join(';') || undefined,\n    head: head,\n    deprel: deprel,\n    deps: deps,\n    misc: misc.join(';') || undefined\n  };\n}\n\n/**\n * parse an array of strings representing a CG3 analysis ... recall that in CG3,\n *   subTokens have an increasingly hanging indent from their superToken\n *\n * @param {Token} token token to attach the analyses to\n * @param {Array} lines [[String]]\n * @return {undefined}\n */\nfunction cg3StringParseAnalysis(token, lines) {\n\n  if (lines.length === 2) {\n\n    // no subTokens\n    var tags = cg3StringGetTags(lines[1]); // extract tags\n    tags.form = cg3StringGetForm(lines[0]); // extract the form\n    token.pushAnalysis(new Analysis(token, tags)); // save to token\n  } else {\n\n    // has subTokens\n    var analysis = new Analysis(token, {\n      form: cg3StringGetForm(lines[0]) // superToken only save form\n    });\n\n    // for each subToken\n    for (var i = 1; i < lines.length; i++) {\n      var _tags = cg3StringGetTags(lines[i]); // extract tags\n      var subToken = new Token(token.sentence, _tags); // make new subToken\n      analysis.pushSubToken(subToken); // attach to this analysis\n    }\n    token.pushAnalysis(analysis); // save to token\n  }\n}\n\n// define all the CG3-parsing regex here\nvar cg3Regex = {\n  form: /^\"<((.|\\\\\")*)>\"/,\n  lemma: /[\"\\]](.*)[\"\\]](\\s|$)/,\n  head: /->(.*)$/,\n  dependency: /^#(.+)->(.*)/,\n  deprel: /^@(.*)/,\n  misc: /.+:.*/\n};\n\n/**\n * this class contains all the information associated with a token, including\n *   a possible superToken, an array of possible analyses, an index to the\n *   current analysis, and a Boolean representing whether it is an \"empty\" token\n */\n\nvar Token = function (_Object) {\n  _inherits(Token, _Object);\n\n  function Token(sent, params) {\n    _classCallCheck(this, Token);\n\n    // require sentence param\n    var _this = _possibleConstructorReturn(this, (Token.__proto__ || Object.getPrototypeOf(Token)).call(this));\n\n    if (!sent) throw new NotatrixError('missing required arg: Sentence');\n\n    // pointer to parent\n    _this.sentence = sent;\n\n    // internal stuff\n    _this.superToken = null;\n    _this.analyses = []; // array of analyses\n    _this._current = null; // index of current analysis in array\n    _this._isEmpty = false; // used for CoNLL-U \"empty\" tokens\n\n    // try parsing an analysis from params\n    if (params) _this.analysis = new Analysis(_this, params);\n    return _this;\n  }\n\n  /**\n   *\n   * @return {Number} total number of analyses in this token\n   */\n\n\n  _createClass(Token, [{\n    key: 'forEach',\n\n\n    /**\n     * loop through every analysis in the sentence and apply a callback\n     *\n     * @param {Function} callback function to be applied to every analysis\n     * @return {Token}\n     */\n    value: function forEach(callback) {\n\n      for (var i = 0; i < this.length; i++) {\n        callback(this.analyses[i], i);\n      }\n\n      // chaining\n      return this;\n    }\n\n    // keeping track of ambiguous analyses\n\n    /**\n     * decrement the _current counter by one (set \"previous\" analysis as current)\n     *\n     * @return {Token}\n     */\n\n  }, {\n    key: 'prev',\n    value: function prev() {\n\n      // if no analyses set whatsoever\n      if (this._current === null) return null;\n\n      // if we're not already at the first one\n      if (this._current > 0) this._current--;\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * increment the _current counter by one (set \"next\" analysis as current)\n     *\n     * @return {Token}\n     */\n\n  }, {\n    key: 'next',\n    value: function next() {\n\n      // if no analyses set whatsoever\n      if (this._current === null) return null;\n\n      // if we're not already at the last one\n      if (this._current < this.length - 1) this._current++;\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * return the _current index\n     *\n     * @return {Number}\n     */\n\n  }, {\n    key: 'insertAnalysisAt',\n\n\n    // manipulate analyses array\n\n    /**\n     * insert an analysis BEFORE the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length), then it will be adjusted\n     *   to fit the bounds. this means that you can call this with `index=-Infinity`\n     *   to push to the front of the analyses array or with `index=Infinity` to push\n     *   to the end\n     *\n     * @param {Number} index\n     * @param {Analysis} analysis\n     * @return {Token}\n     *\n     * @throws {NotatrixError} if given invalid index or analysis\n     */\n    value: function insertAnalysisAt(index, analysis) {\n\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to insert subToken: unable to cast index to int');\n\n      if (!(analysis instanceof Analysis)) throw new NotatrixError('unable to insert analysis: not instance of Analysis');\n\n      // if we had no analyses, make this the first\n      if (this.current === null) this._current = 0;\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.length ? this.length : parseInt(index);\n\n      // set the parent pointer on the analysis\n      analysis.token = this;\n\n      // array insertion\n      this.analyses = this.analyses.slice(0, index).concat(analysis).concat(this.analyses.slice(index));\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * remove an analysis at the given index\n     *\n     * NOTE: if the index is out of bounds (<0 or >length - 1), then it will be\n     *   adjusted to fit the bounds. this means that you can call this with\n     *   `index=-Infinity` to remove the first element of the analyses array or\n     *   with `index=Infinity` to remove the last\n     *\n     * @param {Number} index\n     * @return {(null|Analysis)}\n     *\n     * @throws {NotatrixError} if given invalid index\n     */\n\n  }, {\n    key: 'removeAnalysisAt',\n    value: function removeAnalysisAt(index) {\n\n      // can't remove if we have an empty array\n      if (!this.length) return null;\n\n      index = parseFloat(index); // catch Infinity\n      if (isNaN(index)) throw new NotatrixError('unable to remove subToken: unable to cast index to int');\n\n      // bounds checking\n      index = index < 0 ? 0 : index > this.length - 1 ? this.length - 1 : parseInt(index);\n\n      // go to previous analysis if we just deleted our current one or before it\n      if (this.current >= index) this.prev();\n\n      // if we now have an empty array, update _current\n      if (this.length === 1) this._current = null;\n\n      // array splicing, return spliced element\n      return this.analyses.splice(index, 1)[0];\n    }\n\n    /**\n     * move an analysis from sourceIndex to targetIndex\n     *\n     * NOTE: if either index is out of bounds (<0 or >length - 1), then it will\n     *   be adjusted to fit the bounds. this means that you can call this with\n     *   `sourceIndex=-Infinity` to select the first element of the analyses array\n     *   or with `sourceIndex=Infinity` to select the last\n     *\n     * @param {Number} sourceIndex\n     * @param {Number} targetIndex\n     * @return {Token}\n     *\n     * @throws {NotatrixError} if given invalid sourceIndex or targetIndex\n     */\n\n  }, {\n    key: 'moveAnalysisAt',\n    value: function moveAnalysisAt(sourceIndex, targetIndex) {\n\n      sourceIndex = parseFloat(sourceIndex);\n      targetIndex = parseFloat(targetIndex);\n      if (isNaN(sourceIndex) || isNaN(targetIndex)) throw new NotatrixError('unable to move analysis: unable to cast indices to ints');\n\n      // bounds checking\n      sourceIndex = sourceIndex < 0 ? 0 : sourceIndex > this.length - 1 ? this.length - 1 : parseInt(sourceIndex);\n      targetIndex = targetIndex < 0 ? 0 : targetIndex > this.length - 1 ? this.length - 1 : parseInt(targetIndex);\n\n      if (sourceIndex === targetIndex) {\n        // do nothing\n      } else {\n\n        // array splice and insert\n        var analysis = this.analyses.splice(sourceIndex, 1);\n        this.analyses = this.analyses.slice(0, targetIndex).concat(analysis).concat(this.analyses.slice(targetIndex));\n      }\n\n      // chaining\n      return this;\n    }\n\n    /**\n     * push an analysis to the end of the analyses array ... sugar for\n     *   Token::insertAnalysisAt(Infinity, analysis)\n     *\n     * @param {Analysis} analysis\n     * @return {Token}\n     */\n\n  }, {\n    key: 'pushAnalysis',\n    value: function pushAnalysis(analysis) {\n      return this.insertAnalysisAt(Infinity, analysis);\n    }\n\n    /**\n     * pop an analysis from the end of the analyses array ... sugar for\n     *   Token::insertRemoveAt(Infinity)\n     *\n     * @return {(null|Analysis)}\n     */\n\n  }, {\n    key: 'popAnalysis',\n    value: function popAnalysis() {\n      return this.removeAnalysisAt(Infinity);\n    }\n\n    // token insertion, removal, moving // TODO\n    /*insertBefore(token) {\n      const indices = this.getIndices();\n      return this.sentence.insertTokenAt(indices, token);\n    }\n    insertAfter(token) {\n      const indices = this.getIndicesAfter();\n      return this.sentence.insertTokenAt(indices, token);\n    }\n    insertSubTokenBefore(subToken) {\n     }\n    insertSubTokenAfter(subToken) {\n     }\n    remove() {\n     }\n    moveBefore(token) {\n     }\n    moveAfter(token) {\n     }\n    makeSubTokenOf(token) {\n     }\n     // token combining, merging, splitting\n    combineWith(token) {\n     }\n    mergeWith(token) {\n     }\n    split() {\n     }*/\n\n    // internal format\n\n    /**\n     * get the current analysis for the token or null if none exist\n     *\n     * @return {(null|Analysis)}\n     */\n\n  }, {\n    key: 'index',\n\n\n    // external format stuff\n\n    /**\n     * iterate over this token and its subTokens (if we have any) for the current\n     *   analysis, using the `id` and `empty` params to set indices\n     *\n     * @param {Number} id \"overall\" index\n     * @param {Number} empty\n     * @return {Array} [Number, Number]\n     *\n     * @throws {NotatrixError} if given invalid id or empty\n     */\n    value: function index(id, empty) {\n      var _this2 = this;\n\n      if (isNaN(parseInt(id))) throw new NotatrixError('can\\'t index tokens using non-integers, make sure to call Sentence.index()');\n\n      // if no analysis, nothing to do\n      if (this.analysis === null) return id;\n\n      // iterate over analyses\n      this.forEach(function (analysis) {\n\n        // only set the indices on the current analysis\n        if (analysis === _this2.analysis) {\n          if (_this2.isSuperToken) {\n\n            // index subTokens\n            _.each(_this2.analysis.subTokens, function (subToken) {\n              if (subToken.isEmpty) {\n                empty++; // incr empty counter\n                subToken.analysis.id = id + '.' + empty; // dot syntax\n              } else {\n                id++; // incr regular counter\n                subToken.analysis.id = '' + id; // vanilla syntax\n                empty = 0; // reset empty counter\n              }\n            });\n\n            // set special superToken index scheme\n            var firstSubAnalysis = _this2.subTokens[0].analysis;\n            var lastSubAnalysis = _this2.subTokens[_this2.analysis.length - 1].analysis;\n            _this2.analysis.id = firstSubAnalysis.id + '-' + lastSubAnalysis.id;\n          } else {\n            if (_this2.isEmpty) {\n              empty++; // incr empty counter\n              _this2.analysis.id = id + '.' + empty; // dot syntax\n            } else {\n              id++; // incr regular counter\n              _this2.analysis.id = '' + id; // vanilla syntax\n              empty = 0; // reset empty counter\n            }\n          }\n        } else {\n\n          // non-current analyses get indices set to null\n          analysis.id = null;\n          _.each(analysis.subTokens, function (subToken) {\n            subToken.analysis.id = null;\n          });\n        }\n      });\n\n      // return updated indices\n      return [id, empty];\n    }\n\n    /**\n     * get a serial version of the internal token representation\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n\n      return this.analyses.length;\n    }\n  }, {\n    key: 'current',\n    get: function get() {\n\n      return this._current;\n    }\n\n    /**\n     * set the _current index to the given index if possible\n     *\n     * @param {Number} current\n     * @return {Number}\n     */\n    ,\n    set: function set(current) {\n\n      // force cast to int\n      current = parseInt(current);\n      if (isNaN(current)) return this.current;\n\n      // bounds checking\n      if (current < 0) return this.current;\n      if (current > this.length - 1) return this.current;\n\n      // set and return it\n      this._current = current;\n      return this.current;\n    }\n  }, {\n    key: 'analysis',\n    get: function get() {\n\n      if (this.current === null) return null;\n      return this.analyses[this.current];\n    }\n\n    /**\n     * set the current analysis for the token\n     *\n     * NOTE: if there is already an analysis, overwrite\n     *\n     * @param {Analysis} analysis\n     * @return {Token}\n     *\n     * @throws {NotatrixError} if given invalid analysis\n     */\n    ,\n    set: function set(analysis) {\n\n      if (!(analysis instanceof Analysis)) throw new NotatrixError('unable to set analysis: not instance of Analysis');\n\n      if (this.analysis === null) {\n        // push to front if we have no analyses\n        this.insertAnalysisAt(0, analysis);\n      } else {\n        // otherwise overwrite\n        analysis.token = this;\n        this.analyses[this.current] = analysis;\n      }\n\n      return this;\n    }\n\n    /**\n     * if we have a current analysis, return its subTokens\n     *\n     * @return {(null|Array)}\n     */\n\n  }, {\n    key: 'subTokens',\n    get: function get() {\n\n      if (this.analysis === null) return null;\n      return this.analysis.subTokens;\n    }\n  }, {\n    key: 'nx',\n    get: function get() {\n\n      // serialize analyses\n      var analyses = [];\n      this.forEach(function (analysis) {\n        analyses.push(analysis.nx);\n      });\n\n      // serialize other data\n      return {\n        current: this.current,\n        analyses: analyses\n      };\n    }\n\n    /**\n     * get a plain-text formatted string of the current analysis text\n     *\n     * @return {String}\n     *\n     * @throws {NotatrixError} if no analysis\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n\n      if (this.analysis === null) throw new NotatrixError('no analysis to get text for');\n\n      return this.analysis.text || '';\n    }\n\n    /**\n     * get a CoNLL-U formatted string representing the current analysis\n     *\n     * @return {String}\n     *\n     * @throws {NotatrixError} if no analysis\n     * @throws {InvalidCoNLLUError} if ambiguous\n     */\n\n  }, {\n    key: 'conllu',\n    get: function get() {\n\n      if (this.analysis === null) throw new NotatrixError('no analysis to get CoNLL-U for');\n\n      if (this.isAmbiguous) throw new InvalidCoNLLUError('Token is ambiguous, can\\'t be converted to CoNNL-U');\n\n      return this.analysis.conllu;\n    }\n\n    /**\n     * parse a CoNLL-U formatted string and save its contents to the current analysis\n     *\n     * @param {String} serial\n     * @return {undefined}\n     */\n    ,\n    set: function set(serial) {\n      // split serial string on whitespace\n      var fields = split(serial);\n\n      // check if serial index indicates an \"empty\" token\n      this._isEmpty = /\\./.test(fields[0]);\n\n      // generate an analysis from the fields\n      this.analysis = new Analysis(this, {\n        form: fields[1],\n        lemma: fields[2],\n        upostag: fields[3],\n        xpostag: fields[4],\n        feats: fields[5],\n        head: fields[6],\n        deprel: fields[7],\n        deps: fields[8],\n        misc: fields[9]\n      });\n    }\n\n    /**\n     * static method allowing us to construct a new Token directly from a\n     *   CoNLL-U string and bind it to a sentence\n     *\n     * @param {Sentence} sent\n     * @param {String} serial\n     * @return {Token}\n     */\n\n  }, {\n    key: 'cg3',\n\n\n    /**\n     * get a CG3 formatted string representing the current analysis\n     *\n     * @return {String}\n     *\n     * @throws {NotatrixError} if no analysis\n     */\n    get: function get() {\n      if (this.analysis === null) throw new NotatrixError('no analysis to get CG3 for');\n\n      // the form goes on its own line, with each analysis below\n      return ['\"<' + this.analysis.form + '>\"'].concat(this.analyses.map(function (analysis) {\n        return analysis.cg3;\n      })).join('\\n');\n    }\n\n    /**\n     * parse a CG3 formatted string and save its contents to the current analysis\n     *\n     * @param {Array} tokenLines generated in Sentence::cg3 [set] by splitting\n     *   a serial string on newlines\n     * @return {undefined}\n     */\n    ,\n    set: function set(tokenLines) {\n      // again, we have complicated parsing here ... first make sure we get an\n      //   array of the important information (minimally the form on the first line)\n      var analysis = [tokenLines[0]];\n\n      // iterate over the strings\n      for (var i = 1; i < tokenLines.length; i++) {\n\n        // ignore leading semicolons (TODO: determine what these are)\n        var line = tokenLines[i].replace(/^;/, '');\n\n        // determine line indent\n        var indent = getIndent(line);\n\n        // if we're back at indent=1 and we already have stuff in our analysis\n        //   buffer, parse it as an analysis\n        if (indent === 1 && i > 1) {\n          // parse as analysis\n          cg3StringParseAnalysis(this, analysis);\n          // reset buffer\n          analysis = [tokenLines[0]];\n        }\n\n        // add to buffer\n        analysis.push(line);\n      }\n\n      // parse and clear buffer\n      cg3StringParseAnalysis(this, analysis);\n    }\n\n    /**\n     * static method allowing us to construct a new Token directly from a\n     *   CG3 string\n     *\n     * @param {Sentence} sent\n     * @param {Array} tokenLines\n     * @return {Token}\n     */\n\n  }, {\n    key: 'params',\n\n\n    /**\n     * get the token parameters for the current analysis\n     *\n     * @return {Object}\n     *\n     * @throws {NotatrixError} if no analysis\n     */\n    get: function get() {\n      if (this.analysis === null) throw new NotatrixError('no analysis to get params for');\n\n      return this.analysis.params;\n    }\n\n    /**\n     * set a set of parameters as the current analysis\n     *\n     * @param {Object} params\n     * @return {Object}\n     */\n    ,\n    set: function set(params) {\n      this.analysis = new Analysis(this, params);\n      return this.params;\n    }\n\n    /**\n     * static method allowing us to construct a new Token directly from a set\n     *   of parameters\n     *\n     * @param {Sentence} sent\n     * @param {Object} params\n     * @return {Token}\n     */\n\n  }, {\n    key: 'eles',\n    get: function get() {\n      throw new Error('Token::eles [get] is not implemented'); // TODO\n    }\n\n    // bool stuff\n\n    /**\n     * returns true iff this token is a subToken of some other token\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSubToken',\n    get: function get() {\n      return this.superToken !== null;\n    }\n\n    /**\n     * returns true iff this token has subTokens\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSuperToken',\n    get: function get() {\n      return this.analysis ? this.analysis.isSuperToken : null;\n    }\n\n    /**\n     * returns true iff this token or its superToken is an \"empty\" token\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.isSubToken ? this.superToken.token.isEmpty : this._isEmpty;\n    }\n\n    /**\n     * return true iff this token has more than one analysis\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAmbiguous',\n    get: function get() {\n      return this.length > 1;\n    }\n  }], [{\n    key: 'fromConllu',\n    value: function fromConllu(sent, serial) {\n      var token = new Token(sent);\n      token.conllu = serial;\n      return token;\n    }\n  }, {\n    key: 'fromCG3',\n    value: function fromCG3(sent, tokenLines) {\n      var token = new Token(sent);\n      token.cg3 = tokenLines;\n      return token;\n    }\n  }, {\n    key: 'fromParams',\n    value: function fromParams(sent, params) {\n      var token = new Token(sent);\n      token.params = params;\n      return token;\n    }\n  }]);\n\n  return Token;\n}(Object);\n\n// expose to application\n\n\nmodule.exports = Token;\n\n},{\"./analysis\":2,\"./errors\":3,\"underscore\":1}]},{},[4]);\n"]}